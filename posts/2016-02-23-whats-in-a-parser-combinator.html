<!DOCTYPE html><html lang="en" dir="ltr"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>What's in a parser combinator?</title><meta name="description" content="Simplex Sigillum Veri"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="canonical" href="https://remusao.github.io/posts/whats-in-a-parser-combinator.html"><link rel="icon" type="image/x-icon" href="/images/favicon.ico"><style type="text/css">body{color:#2f2f2f;font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Oxygen-Sans,Ubuntu,Cantarell,'Helvetica Neue',sans-serif;line-height:1.6em;margin:20px auto;max-width:40rem;padding:0 1.5em;text-rendering:optimizeLegibility}h1{line-height:1.1em}h2{border-bottom:1px solid #eaecef;padding-bottom:.5em}h1,h2,h3{padding-top:.7em}.header{color:#555;margin-top:-.8em}.main a{color:#3465a4}.main a:visited{color:#75507b}.main figcaption{color:#696f72;font-style:italic;line-height:2em;text-align:center}.main img{display:block;height:auto;margin:auto;padding-bottom:1em;padding-top:1em;width:90%}.main blockquote{border-left:thin solid #d3d7cf;color:#555;margin:10px;padding:0 0 0 1em}code{background-color:#f6f8fa;font-family:SFMono-Regular,Consolas,Liberation Mono,Menlo,monospace;font-size:14px;line-height:20px;padding:.2em .4em}pre code{display:block;overflow-x:auto}.leave-comment-btn,summary{font-size:16px;font-weight:600}.leave-comment-btn{background-color:#28a745;background-image:linear-gradient(-180deg,#34d058,#28a745 90%);border:1px solid rgba(27,31,35,.2);border-radius:.25em;color:#fff;display:inline-block;margin-top:1.5em;padding:3px 10px;text-decoration:none}.leave-comment-btn:hover{box-shadow:0 1px 3px rgba(0,0,0,.24)}summary{color:#516ae8;cursor:pointer;line-height:1.2rem;margin-top:2rem}.comments-list{list-style:none;padding:0}.comment{background-color:#fff;border:1px solid #d1d5da;border-radius:3px;color:#24292e;font-size:16px;margin:1em 0}.meta{background-color:#f6f8fa;border-bottom:1px solid #d1d5da;color:#586069}.author,.date{text-decoration:none}.author{color:#24292e!important;font-weight:700}.date{color:#586069}.date:hover{color:#0366d6}.content{padding-left:20px}.avatar,.emoji{vertical-align:middle}.avatar{display:inline-block;margin-right:5px}.emoji{height:1.1em;width:1.1em}table{border-collapse:collapse;margin:auto}td,th{border:1px solid #ddd;padding:10px}tr:hover{background-color:#f5f5f5}footer{border-top:thin solid #d3d7cf;margin:1.5em 0}.share ul{text-align:right}.share li{display:inline;padding:0 5px}.share img{width:32px}.main a,header a{text-decoration:none}.hljs{background:#f8f8f8;color:#333;display:block;overflow-x:auto;padding:.5em}.hljs-comment,.hljs-quote{color:#6a737d;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#d73a49}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:#005cc5}.hljs-doctag,.hljs-string{color:#032f62}.hljs-section,.hljs-selector-id,.hljs-title{color:#900}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#6f42c1}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style></head><body><main><header><h1><a href="../"><span>../</span></a></h1></header><h1>What's in a parser combinator?</h1><section class="header"><div>└─ 2016-02-23 • <em>Reading time: ~13 minutes</em></div></section><article><div class="main"><p>As part of my ongoing effort to make progress in Haskell (that’s one of my goals for 2016!), I’m following the [MOOC on functionnal programming](<a href="https://courses.edx.org/courses/course-v1:DelftX+FP101x+3T2">https://courses.edx.org/courses/course-v1:DelftX+FP101x+3T2</a> 015/info) by <a href="https://twitter.com/headinthebox">Erik Meijer</a> on <em>edX</em>.</p><p>The first lessons were pretty basic stuff, and I got through them quickly. Lesson 7 is about <em>Functional parsers</em> and M***** (scary). This is where I encountered my first difficulties, and I thought it would be an interesting writing. I already used parser combinators in Haskell before (mainly <a href="https://hackage.haskell.org/package/parsec">Parsec</a> and <a href="http://hackage.haskell.org/package/attoparsec">Attoparsec</a>), but never really understood how they worked, or at least not enough to implement one myself. So here is my take on the subject. Don’t expect really advanced stuff! It’s just an introduction to the basic concepts, on which we could build more complex and useful tools. In particular, <strong>I won’t talk about</strong>:</p><ol><li>How to report errors.</li><li>How to recover from errors.</li><li>How to write a parser for a concrete grammar.</li></ol><p>Instead <strong>I’ll focus on</strong>:</p><ol><li>What a parser <em>is</em>.</li><li>How to make parsers <em>compose</em>.</li><li>How to use <em>do notation</em> to implement more complex parsers.</li></ol><p>One of the interesting facts about writing your own parser combinators library, is that you will learn (or consolidate) other knowledges in the process, like: <em>Functors</em>, <em>Applicatives</em> and, of course, <em>Monads</em>, and more generaly, how to <em>design DSL in Haskell*. I already knew about this concepts (at least, that’s what I thought…), but knowing what something is from a high level of abstraction, *is not the same as knowing how to implement it on a concrete type</em> (like a Parser)!</p><h3 id="so-whats-a-parser">So what’s a parser?</h3><p>We can view a <em>Parser</em> as <em>something</em> that consumes some input, and outputs a structured representation of what was consumed. For the sake of simplicity, we’ll only consume strings (Haskell type <code>String</code>). So that would be something like:</p><pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">Parser</span> a = <span class="hljs-type">String</span> -&gt; a</span></code></pre><p>Here <code>a</code> represents the type of what is <em>built</em> from the stream of characters (<code>String</code>). This could be a syntactic tree, or a list of numbers, or anything else. For example a parser that is able to recognize a string like <code>&quot;[1, 2, 3, 4]&quot;</code> could have the type: <code>Parser [Int]</code> (expended to <code>String -&gt; [Int]</code>), which means it takes a <code>String</code> and output a <code>list</code> of integers.</p><p>But we’re missing two important properties of a <em>Parser</em>:</p><ol><li>It can <strong>fail to parse</strong> something.</li><li>It can <strong>partially consume</strong> its input.</li></ol><p>To take into account the first point, we could return <code>Maybe a</code> instead of <code>a</code> (resulting in <code>Nothing</code> in case of failure). Note that we could also use a richer type like <code>Either</code> to handle parsing errors. And for the second point, we can return a tuple of a <code>a</code> and a <code>String</code>, which represents the part of the string that wasn’t consumed by the parser. The type would then become:</p><pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Parser</span> a = <span class="hljs-type">Parser</span> { <span class="hljs-title">runParser</span> :: <span class="hljs-type">String</span> -&gt; <span class="hljs-type">Maybe</span> (<span class="hljs-title">a</span>, <span class="hljs-type">String</span>) }</span></code></pre><p>As an example of a parser that would fail, if you take our previous <em>parser</em> that is able to handle a list of integers, if you give it the string <code>&quot;[1 ,2&quot;</code>, it will fail, and return <code>Nothing</code>.</p><p>Similarly, if we feed the <em>parser</em> with <code>&quot;[1, 2, 3, 4]toto&quot;</code>, it will consume the part of the string that represents the list of integers, and leave <code>&quot;toto&quot;</code> as a remaining input. Thus the result would be: <code>Just ([1, 2, 3, 4], &quot;toto&quot;)</code>.</p><p>Let’s implement some very basic parsers:</p><pre><code class="language-haskell"><span class="hljs-comment">-- This parser always fails</span>
<span class="hljs-title">failure</span> :: <span class="hljs-type">Parser</span> a
<span class="hljs-title">failure</span> = <span class="hljs-type">Parser</span> $ \s -&gt; <span class="hljs-type">Nothing</span></code></pre><pre><code class="language-haskell"><span class="hljs-comment">-- This parser always succeeds and returns the value given as input</span>
<span class="hljs-comment">-- (leaving the input string intact)</span>
<span class="hljs-title">return</span> :: a -&gt; <span class="hljs-type">Parser</span> a
<span class="hljs-title">return</span> a = <span class="hljs-type">Parser</span> $ \s -&gt; <span class="hljs-type">Just</span> (a, s)</code></pre><pre><code class="language-haskell"><span class="hljs-comment">-- This parser returns the first char of the input string, and</span>
<span class="hljs-comment">-- fail on empty input</span>
<span class="hljs-title">oneChar</span> :: <span class="hljs-type">Parser</span> <span class="hljs-type">Char</span>
<span class="hljs-title">oneChar</span> = <span class="hljs-type">Parser</span> $ \s -&gt; <span class="hljs-keyword">case</span> s <span class="hljs-keyword">of</span>
            [] -&gt; <span class="hljs-type">Nothing</span>
            (c:xs) -&gt; <span class="hljs-type">Just</span> (c, xs)</code></pre><p>Let’s test these parsers:</p><pre><code class="language-haskell"><span class="hljs-title">runParser</span> failure <span class="hljs-string">"Hello Parser!"</span></code></pre><blockquote><pre><code class="language-haskell"><span class="hljs-type">Nothing</span></code></pre></blockquote><pre><code class="language-haskell"><span class="hljs-title">runParser</span> (return <span class="hljs-number">42</span>) <span class="hljs-string">"Hello Parser!"</span></code></pre><blockquote><pre><code class="language-haskell"><span class="hljs-type">Just</span> (<span class="hljs-number">42</span>, <span class="hljs-string">"Hello Parser!"</span>)</code></pre></blockquote><pre><code class="language-haskell"><span class="hljs-title">runParser</span> oneChar <span class="hljs-string">"Hello Parser!"</span></code></pre><blockquote><pre><code class="language-haskell"><span class="hljs-type">Just</span> ('<span class="hljs-type">H'</span>,<span class="hljs-string">"ello Parser!"</span>)</code></pre></blockquote><pre><code class="language-haskell"><span class="hljs-title">runParser</span> oneChar <span class="hljs-string">""</span></code></pre><blockquote><pre><code class="language-haskell"><span class="hljs-type">Nothing</span></code></pre></blockquote><p>The basic parsers seem to behave as expected. We get <code>Nothing</code> in case of failure, and they are able to partially consume the input. So all is good, but what about more complex parsers? We would like to parse strings, or more complex patterns. Let’s try to recognize a string from the input, using our basic parsers:</p><pre><code class="language-haskell"><span class="hljs-title">string</span> :: <span class="hljs-type">String</span> -&gt; <span class="hljs-type">Parser</span> <span class="hljs-type">String</span>
<span class="hljs-title">string</span> <span class="hljs-string">""</span> = return <span class="hljs-string">""</span>
<span class="hljs-title">string</span> (c1:xs1) = <span class="hljs-type">Parser</span> $ \s -&gt;
  <span class="hljs-keyword">case</span> runParser oneChar s <span class="hljs-keyword">of</span>
    <span class="hljs-type">Nothing</span> -&gt; <span class="hljs-type">Nothing</span>
    <span class="hljs-type">Just</span> (c2, rest) -&gt;
      <span class="hljs-keyword">if</span> c1 == c2
      <span class="hljs-keyword">then</span> <span class="hljs-keyword">case</span> runParser (string xs1) rest <span class="hljs-keyword">of</span>
        <span class="hljs-type">Nothing</span> -&gt; <span class="hljs-type">Nothing</span>
        <span class="hljs-type">Just</span> (match, rest2) -&gt; <span class="hljs-type">Just</span> (c2:match, rest2)
      <span class="hljs-keyword">else</span> <span class="hljs-type">Nothing</span></code></pre><pre><code class="language-haskell"><span class="hljs-title">runParser</span> (string <span class="hljs-string">"Hello"</span>) <span class="hljs-string">"Hello Parser!"</span></code></pre><blockquote><pre><code class="language-haskell"><span class="hljs-type">Just</span> (<span class="hljs-string">"Hello"</span>, <span class="hljs-string">" Parser!"</span>)</code></pre></blockquote><pre><code class="language-haskell"><span class="hljs-title">runParser</span> (string <span class="hljs-string">"Hello"</span>) <span class="hljs-string">"Foo Bar"</span></code></pre><blockquote><pre><code class="language-haskell"><span class="hljs-type">Nothing</span></code></pre></blockquote><pre><code class="language-haskell"><span class="hljs-title">runParser</span> (string <span class="hljs-string">""</span>) <span class="hljs-string">"Hello Parser!"</span></code></pre><blockquote><pre><code class="language-haskell"><span class="hljs-type">Just</span> (<span class="hljs-string">""</span>,<span class="hljs-string">"Hello Parser!"</span>)</code></pre></blockquote><p>This isn’t very convenient (but it works)… Because we have to write the boilerplate to <em>compose parsers</em> over and over. Hopefully, we know a famous structure that allows composition in Haskell, and this is called <em>Monad</em> (and I won’t make yet another tutorial on <em>Monads</em>, so I will assume you already are familiar with this concept). That means we could avoid all the boilerplate, by making our <code>Parser</code> type an instance of <em>Monad*. This would allow us to use the *do syntax</em> to cleanly compose our parsers! Sweet!</p><p>To do so, we’ll have to make our <em>Parser</em> an instance of: <em>Functor</em>, <em>Applicative</em> and <em>Monad</em>.</p><h4 id="parser-is-a-functor">Parser is a Functor</h4><p>First of all, our Parser is an instance of <a href="https://en.wikibooks.org/wiki/Haskell/The_Functor_class"><em>Functor</em></a>, which means we can <code>map</code> functions over the result of our parsing:</p><pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Functor</span> <span class="hljs-type">Parser</span> <span class="hljs-keyword">where</span></span>
    <span class="hljs-comment">-- fmap :: (a -&gt; b) -&gt; Parser a -&gt; Parser b</span>
    <span class="hljs-comment">-- 1. Run parser on input string.</span>
    <span class="hljs-comment">-- 2. Apply function on result of parsing.</span>
    fmap f p = <span class="hljs-type">Parser</span> $ \s -&gt;
      <span class="hljs-keyword">case</span> runParser p s <span class="hljs-keyword">of</span>
        <span class="hljs-type">Nothing</span> -&gt; <span class="hljs-type">Nothing</span>
        <span class="hljs-type">Just</span> (a, rest) -&gt; <span class="hljs-type">Just</span> (f a, rest)</code></pre><pre><code class="language-haskell"><span class="hljs-comment">-- Parse `String` "42" and then convert it to `Int` using `read`</span>
<span class="hljs-title">parse42</span> :: <span class="hljs-type">Parser</span> <span class="hljs-type">Int</span>
<span class="hljs-title">parse42</span> = (fmap read $ string <span class="hljs-string">"42"</span>)

<span class="hljs-title">runParser</span> parse42 <span class="hljs-string">"42 is the answer!"</span></code></pre><blockquote><pre><code class="language-haskell"><span class="hljs-type">Just</span> (<span class="hljs-number">42</span>, <span class="hljs-string">" is the answer!"</span>)</code></pre></blockquote><h4 id="parser-is-an-applicative">Parser is an Applicative</h4><p>Secondly, we can make our parser an instance of <a href="https://en.wikibooks.org/wiki/Haskell/Applicative_functors"><em>Applicative</em></a>. This part wasn’t obvious for me. All the examples I found were about instances for easy types like <code>Maybe</code>, but I found a <em>Parser</em> to be pretty different. But thanks to the types and some use-cases (that you’ll find below), I figured the following implementation (which will hopefully be correct…):</p><pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Applicative</span> <span class="hljs-type">Parser</span> <span class="hljs-keyword">where</span></span>
    <span class="hljs-comment">-- pure :: a -&gt; Parser a</span>
    <span class="hljs-comment">-- Wrap a value inside a parser, leaving input unchanged.</span>
    pure a = <span class="hljs-type">Parser</span> $ \s -&gt; <span class="hljs-type">Just</span> (a, s)
    <span class="hljs-comment">-- (&lt;*&gt;) :: Parser (a -&gt; b) -&gt; Parser a -&gt; Parser b</span>
    <span class="hljs-comment">-- 1. Run first parser on input (resulting in a function (a -&gt; b).</span>
    <span class="hljs-comment">-- 2. Run second parser on remaining input, left by first parser.</span>
    <span class="hljs-comment">-- 3. Apply function (a -&gt; b) on result of second parser.</span>
    p1 &lt;*&gt; p2 = <span class="hljs-type">Parser</span> $ \s -&gt;
      <span class="hljs-keyword">case</span> runParser p1 s <span class="hljs-keyword">of</span>
        <span class="hljs-type">Nothing</span> -&gt; <span class="hljs-type">Nothing</span>
        <span class="hljs-type">Just</span> (f, rest) -&gt; <span class="hljs-keyword">case</span> runParser p2 rest <span class="hljs-keyword">of</span>
          <span class="hljs-type">Nothing</span> -&gt; <span class="hljs-type">Nothing</span>
          <span class="hljs-type">Just</span> (a, rest2) -&gt; <span class="hljs-type">Just</span> (f a, rest2)</code></pre><p>The usefulness of the previous instance might not be obvious, but it allows us to <code>lift</code> some function inside the realm of parsers. For example if we want to take the result of several parsers and then group their results into a tuple, we can do it using <em>Applicatives</em>:</p><pre><code class="language-haskell"><span class="hljs-title">parseTuple</span> :: <span class="hljs-type">Parser</span> (<span class="hljs-type">Char</span>, <span class="hljs-type">Char</span>)
<span class="hljs-title">parseTuple</span> =  (,) &lt;$&gt; oneChar &lt;*&gt; oneChar
<span class="hljs-title">runParser</span> parseTuple <span class="hljs-string">"ab"</span></code></pre><blockquote><pre><code class="language-haskell"><span class="hljs-type">Just</span> (('a', 'b'), <span class="hljs-string">""</span>)</code></pre></blockquote><p>This is the kind of constructs we will use to convert the raw parsed structure into our own types (e.g: an AST).</p><pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">AST</span> =</span>
    <span class="hljs-type">Foo</span> <span class="hljs-type">String</span>
  | <span class="hljs-type">Bar</span> <span class="hljs-type">String</span>
  | <span class="hljs-type">Pair</span> <span class="hljs-type">Char</span> <span class="hljs-type">Char</span>
  <span class="hljs-keyword">deriving</span> (<span class="hljs-type">Show</span>)

<span class="hljs-title">parseFoo</span>, parseBar, parsePair :: <span class="hljs-type">Parser</span> <span class="hljs-type">AST</span>
<span class="hljs-title">parseFoo</span> = <span class="hljs-type">Foo</span> &lt;$&gt; string <span class="hljs-string">"foo"</span>
<span class="hljs-title">parseBar</span> = <span class="hljs-type">Bar</span> &lt;$&gt; string <span class="hljs-string">"bar"</span>
<span class="hljs-title">parsePair</span> = <span class="hljs-type">Pair</span> &lt;$&gt; oneChar &lt;*&gt; oneChar</code></pre><pre><code class="language-haskell"><span class="hljs-title">runParser</span> parseFoo <span class="hljs-string">"foo bar"</span>
<span class="hljs-title">runParser</span> parseBar <span class="hljs-string">"bar baz"</span>
<span class="hljs-title">runParser</span> parsePair <span class="hljs-string">"xyz"</span></code></pre><blockquote><pre><code class="language-haskell"><span class="hljs-type">Just</span> (<span class="hljs-type">Foo</span> <span class="hljs-string">"foo"</span>, <span class="hljs-string">" bar"</span>)</code></pre></blockquote><blockquote><pre><code class="language-haskell"><span class="hljs-type">Just</span>(<span class="hljs-type">Bar</span> <span class="hljs-string">"bar"</span>, <span class="hljs-string">" baz"</span>)</code></pre></blockquote><blockquote><pre><code class="language-haskell"><span class="hljs-type">Just</span> (<span class="hljs-type">Pair</span> 'x' 'y', <span class="hljs-string">"z"</span>)</code></pre></blockquote><h4 id="parser-is-a-monad">Parser is a Monad</h4><p>Last but not least, our parser is a <a href="https://en.wikibooks.org/wiki/Haskell/Understanding_monads"><em>Monad</em></a>. Which means it must implement: <code>&gt;&gt;=</code>, <code>&gt;&gt;</code>, <code>return</code> and <code>fail</code>:</p><pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Monad</span> <span class="hljs-type">Parser</span> <span class="hljs-keyword">where</span></span>
    <span class="hljs-comment">-- (&gt;&gt;=) :: Parser a -&gt; (a -&gt; Parser b) -&gt; Parser b</span>
    <span class="hljs-comment">-- 1. Run first parser on input.</span>
    <span class="hljs-comment">-- 2. Feed result of parsing to `f`.</span>
    <span class="hljs-comment">-- 3. Run second parser (result of `f`) on remaining</span>
    <span class="hljs-comment">--    input (left by first parser)</span>
    p &gt;&gt;= f = <span class="hljs-type">Parser</span> $ \s -&gt; <span class="hljs-keyword">case</span> runParser p s <span class="hljs-keyword">of</span>
                    <span class="hljs-type">Nothing</span> -&gt; <span class="hljs-type">Nothing</span>
                    <span class="hljs-type">Just</span> (a, rest) -&gt; runParser (f a) rest
    <span class="hljs-comment">-- (&gt;&gt;) :: Parser a -&gt; Parser b -&gt; Parser b</span>
    <span class="hljs-comment">-- 1. Run first parser on input.</span>
    <span class="hljs-comment">-- 2. Run second parser on remaining input (left by first parser)</span>
    <span class="hljs-comment">-- We ignore result of first parser.</span>
    p1 &gt;&gt; p2 = <span class="hljs-type">Parser</span> $ \s -&gt; <span class="hljs-keyword">case</span> runParser p1 s <span class="hljs-keyword">of</span>
                    <span class="hljs-type">Nothing</span> -&gt; <span class="hljs-type">Nothing</span>
                    <span class="hljs-type">Just</span> (_, rest) -&gt; runParser p2 rest
    <span class="hljs-comment">-- return :: a -&gt; Parser a</span>
    return = pure
    <span class="hljs-comment">-- fail :: String -&gt; Parser a</span>
    fail _ = <span class="hljs-type">Parser</span> (const <span class="hljs-type">Nothing</span>)</code></pre><p>Thanks to this definition we can use the <code>do</code> syntactic sugar, which will ease the implementation of more complex parsers. Let’s see what we can do.</p><pre><code class="language-haskell"><span class="hljs-comment">-- Parse a specific `Char` from the input</span>
<span class="hljs-title">char</span> :: <span class="hljs-type">Char</span> -&gt; <span class="hljs-type">Parser</span> <span class="hljs-type">Char</span>
<span class="hljs-title">char</span> c = <span class="hljs-keyword">do</span>
    c1 &lt;- oneChar
    <span class="hljs-keyword">if</span> c == c1
       <span class="hljs-keyword">then</span> return c1
       <span class="hljs-keyword">else</span> failure</code></pre><pre><code class="language-haskell"><span class="hljs-title">runParser</span> (char '<span class="hljs-type">H'</span>) <span class="hljs-string">"Hello!"</span>
<span class="hljs-title">runParser</span> (char 'e') <span class="hljs-string">"Hello!"</span></code></pre><blockquote><pre><code class="language-haskell"><span class="hljs-type">Just</span>(‘<span class="hljs-type">H</span>’,“ello!”)</code></pre></blockquote><blockquote><pre><code class="language-haskell"><span class="hljs-type">Nothing</span></code></pre></blockquote><p>We can also implement a cleaner version of our <code>string</code> parser (found above):</p><pre><code class="language-haskell"><span class="hljs-comment">-- Parse a specific pattern from the input</span>
<span class="hljs-title">string'</span> :: <span class="hljs-type">String</span> -&gt; <span class="hljs-type">Parser</span> <span class="hljs-type">String</span>
<span class="hljs-title">string'</span> [] = return []
<span class="hljs-title">string'</span> (c:xs) = <span class="hljs-keyword">do</span>
    c1 &lt;- char c
    rest &lt;- string' xs
    return (c1:rest)</code></pre><pre><code class="language-haskell"><span class="hljs-title">runParser</span> (string' <span class="hljs-string">"Hello"</span>) <span class="hljs-string">"Hello"</span>
<span class="hljs-title">runParser</span> (string' <span class="hljs-string">"Hello"</span>) <span class="hljs-string">"Foo"</span></code></pre><blockquote><pre><code class="language-haskell"><span class="hljs-type">Just</span>(<span class="hljs-string">"Hello"</span>, <span class="hljs-string">""</span>)</code></pre></blockquote><blockquote><pre><code class="language-haskell"><span class="hljs-type">Nothing</span></code></pre></blockquote><p>The <code>do</code> notation makes it very easy to combine parsers! We now have some basic building blocks that we could use to implement more parsing combinators: <code>choice</code>, <code>many</code>, <code>option</code>, etc. But I’ll leave it as an exercise.</p><p>Moreover, it would be interesting to implement an error reporting mechanism, as well as position tracking (to locate errors in the input), but I’ll leave it for another blog-post (or as an exercise for the reader!).</p><h2 id="what-i-learned-while-reinventing-the-wheel">What I learned while reinventing the wheel</h2><p>Implementing (very) basic parsing combinators led me to better understand the foundation of libraries like <em>Parsec</em> or <em>Attoparsec</em>, and to implement not so trivial instances of typeclasses like <em>Applicatives</em> and <em>Monads*. Although basic, I think it’s a good way to be more familiar with the *DSL</em>-like capabilities of Haskell, and to feel the power that the language offers in term of domain-specific modeling.</p></div><div class="comments"></div></article><footer><div class="share"><ul><li><a href="https://www.facebook.com/sharer/sharer.php?u=https://remusao.github.io//posts/whats-in-a-parser-combinator.html&t=What's in a parser combinator?" title="Share on Facebook" target="_blank" rel="noopener noreferrer"><img loading="lazy" alt="Share on Facebook" src="/images/social_flat_rounded_rects_svg/Facebook.svg"><a></a></li><li><a href="https://twitter.com/share?url=https://remusao.github.io//posts/whats-in-a-parser-combinator.html&text=What's in a parser combinator?&via=Pythux" title="Tweet" target="_blank" rel="noopener noreferrer"><img loading="lazy" alt="Tweet" src="/images/social_flat_rounded_rects_svg/Twitter.svg"><a></a></li><li><a href="https://getpocket.com/save?url=https://remusao.github.io//posts/whats-in-a-parser-combinator.html&title=What's in a parser combinator?" title="Add to Pocket" target="_blank" rel="noopener noreferrer"><img loading="lazy" alt="Add to Pocket" src="/images/social_flat_rounded_rects_svg/Pocket.svg"><a></a></li><li><a href="https://news.ycombinator.com/submitlink?u=https://remusao.github.io//posts/whats-in-a-parser-combinator.html&t=What's in a parser combinator?" title="Submit to Hacker News" target="_blank" rel="noopener noreferrer"><img loading="lazy" alt="Submit to Hacker News" src="/images/social_flat_rounded_rects_svg/HackerNews.svg"><a></a></li><li><a href="https://www.reddit.com/submit?url=https://remusao.github.io//posts/whats-in-a-parser-combinator.html&title=What's in a parser combinator?" title="Submit to Reddit" target="_blank" rel="noopener noreferrer"><img loading="lazy" alt="Submit to Reddit" src="/images/social_flat_rounded_rects_svg/Reddit.svg"><a></a></li></ul></div></footer></main></body></html>