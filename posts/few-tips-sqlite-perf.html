<!DOCTYPE html><html lang="en" dir="ltr"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>Getting the most out of SQLite3 with Python</title><meta name="description" content="Simplex Sigillum Veri"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="canonical" href="https://remusao.github.io/posts/few-tips-sqlite-perf.html"><link rel="icon" type="image/x-icon" href="/images/favicon.ico"><style type="text/css">body{color:#2f2f2f;font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Oxygen-Sans,Ubuntu,Cantarell,'Helvetica Neue',sans-serif;line-height:1.6em;margin:20px auto;max-width:40rem;padding:0 1.5em;text-rendering:optimizeLegibility}h1{line-height:1.1em}h2{border-bottom:1px solid #eaecef;padding-bottom:.5em}h1,h2,h3{padding-top:.7em}.header{color:#555;margin-top:-.8em}.main a{color:#3465a4}.main a:visited{color:#75507b}.main figcaption{color:#696f72;font-style:italic;line-height:2em;text-align:center}.main img{display:block;height:auto;margin:auto;padding-bottom:1em;padding-top:1em;width:90%}.main blockquote{border-left:thin solid #d3d7cf;color:#555;margin:10px;padding:0 0 0 1em}code{background-color:#f6f8fa;font-family:SFMono-Regular,Consolas,Liberation Mono,Menlo,monospace;font-size:14px;line-height:20px;padding:.2em .4em}pre code{display:block;overflow-x:auto}.leave-comment-btn,summary{font-size:16px;font-weight:600}.leave-comment-btn{background-color:#28a745;background-image:linear-gradient(-180deg,#34d058,#28a745 90%);border:1px solid rgba(27,31,35,.2);border-radius:.25em;color:#fff;display:inline-block;margin-top:1.5em;padding:3px 10px;text-decoration:none}.leave-comment-btn:hover{box-shadow:0 1px 3px rgba(0,0,0,.24)}summary{color:#516ae8;cursor:pointer;line-height:1.2rem;margin-top:2rem}.comments-list{list-style:none;padding:0}.comment{background-color:#fff;border:1px solid #d1d5da;border-radius:3px;color:#24292e;font-size:16px;margin:1em 0}.meta{background-color:#f6f8fa;border-bottom:1px solid #d1d5da;color:#586069}.author,.date{text-decoration:none}.author{color:#24292e!important;font-weight:700}.date{color:#586069}.date:hover{color:#0366d6}.content{padding-left:20px}.avatar,.emoji{vertical-align:middle}.avatar{display:inline-block;margin-right:5px}.emoji{height:1.1em;width:1.1em}table{border-collapse:collapse;margin:auto}td,th{border:1px solid #ddd;padding:10px}tr:hover{background-color:#f5f5f5}footer{border-top:thin solid #d3d7cf;margin:1.5em 0}.share ul{text-align:right}.share li{display:inline;padding:0 5px}.share img{width:32px}.main a,header a{text-decoration:none}.hljs{background:#f8f8f8;color:#333;display:block;overflow-x:auto;padding:.5em}.hljs-comment,.hljs-quote{color:#6a737d;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#d73a49}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:#005cc5}.hljs-doctag,.hljs-string{color:#032f62}.hljs-section,.hljs-selector-id,.hljs-title{color:#900}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#6f42c1}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style></head><body><main><header><h1><a href="../"><span>../</span></a></h1></header><h1>Getting the most out of SQLite3 with Python</h1><section class="header"><div>└─ 2017-10-21 • <em>Reading time: ~7 minutes</em></div></section><article><div class="main"><p>I’ve recently made heavy use of <code>sqlite3</code> for a project involving a lot of data and processing. My first attempt involved no database at all, and all data would be kept in memory and queries would consist in a mix of dictionary lookups, iteration, conditions, etc. This was nice, but there is only so much you can fit in memory, and re-generating/loading the data from disk to memory became a tedious and time consuming process.</p><p>I decided to give <code>sqlite3</code> a try. This allowed an increase in the amount of data that could be processed, and reduced the loading time of the application to nothing, since only opening a connection to the database was needed. Moreover, I could replace a lot of Python logic by SQL queries.</p><p>I’d like to share a few learnings and findings about this experience.</p><p><strong>TL;DR</strong>:</p><ol><li>Use bulk operations (<em>a.k.a.</em> <code>executemany</code>).</li><li>You don’t need <code>cursors</code> (most of the time).</li><li>Cursors can be iterated upon.</li><li>Use context managers.</li><li>Use pragmas (when it makes sense).</li><li>Postpone index creation.</li><li>Use placeholders to interpolate python values.</li></ol><h2>Use Bulk Operations</h2><p>If you need to insert a lot of rows at once in your database, you really should not use <code>execute</code>. The <code>sqlite3</code> module provides a way to bulk insertions: <code>executemany</code>.</p><p>Instead of doing something like:</p><pre class="code" data-lang="python"><code><span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> iter_data():
    connection.execute(<span class="hljs-string">&#x27;INSERT INTO my_table VALUES (?)&#x27;</span>, row)
</code></pre><p>You can leverage the fact that <code>executemany</code> accepts as argument a generator of <code>tuples</code>:</p><pre class="code" data-lang="python"><code>connection.executemany(
    <span class="hljs-string">&#x27;INSERT INTO my_table VALUE (?)&#x27;</span>,
    iter_data()
)
</code></pre><p>This is not only more concise, it’s also much more efficient. In fact, <code>sqlite3</code> implements <code>execute</code> using <code>executemany</code> behind the scene, but the former inserts a single row instead of many.</p><p>I wrote a small benchmark which consists in inserting a million rows into an empty table (the database lives in memory):</p><ul><li><code>executemany</code>: <strong>1.6</strong> seconds</li><li><code>execute</code>: 2.7 seconds</li></ul><h2>You Don’t Need Cursors</h2><p>…<em>most of the time</em>.</p><p>One thing I often found confusing at the beginning, was <code>cursor</code> management. Examples online and in the documentation often look like:</p><pre class="code" data-lang="python"><code>connection = sqlite3.connect(<span class="hljs-string">&#x27;:memory:&#x27;</span>)
cursor = connection.cursor()
<span class="hljs-comment"># Do something with cursor</span>
</code></pre><p>But most of the time you don’t need a cursor at all, and you can directly use the <code>connection</code> object (it is mentioned at the <a href="https://docs.python.org/3.6/library/sqlite3.html#using-shortcut-methods" target="_blank" rel="noopener noreferrer">end of the documentation</a>).</p><p>Operations such as <code>execute</code> and <code>executemany</code> can be called directly on the connection and <em>will return a cursor</em>. Here is an example to demonstrate that:</p><pre class="code" data-lang="python"><code><span class="hljs-keyword">import</span> sqlite3

connection = sqlite3(<span class="hljs-string">&#x27;:memory:&#x27;</span>)

<span class="hljs-comment"># Create a table</span>
connection.execute(<span class="hljs-string">&#x27;CREATE TABLE events(ts, msg)&#x27;</span>)

<span class="hljs-comment"># Insert values</span>
connection.executemany(
    <span class="hljs-string">&#x27;INSERT INTO events VALUES (?,?)&#x27;</span>,
    [
        (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;foo&#x27;</span>),
        (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;bar&#x27;</span>),
        (<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;baz&#x27;</span>)
    ]
)

<span class="hljs-comment"># Print inserted rows</span>
<span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> connection.execute(<span class="hljs-string">&#x27;SELECT * FROM events&#x27;</span>):
    print(row)
</code></pre><h2>Cursors Can Be Iterated Upon</h2><p>You might often see examples making use of <code>fetchone</code> or <code>fetchall</code> on the result of a <code>SELECT</code> query. But I find that the most natural way to consume the results is to actually iterate on the cursor directly:</p><pre class="code" data-lang="python"><code><span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> connection.execute(<span class="hljs-string">&#x27;SELECT * FROM events&#x27;</span>):
    print(row)
</code></pre><p>This way, you can stop as soon as you got enough results and not waste resources. Of course, if you know beforehand how many results you want, you can use the <code>LIMIT</code> SQL statement instead, but Python generators are very handy and allow you to decouple data generation from data consumption.</p><h2>Use Context Managers</h2><p>Shit happens, even in the middle of a SQL transaction. To avoid having to deal manually with <code>rollback</code> or <code>commit</code>, you can simply use the <code>connection</code> object as a context manager. In the following example we create a table, and insert <em>by mistake</em> duplicated values:</p><pre class="code" data-lang="python"><code><span class="hljs-keyword">import</span> sqlite3
connection = sqlite3.connect(<span class="hljs-string">&#x27;:memory:&#x27;</span>)

<span class="hljs-keyword">with</span> connection:
    connection.execute(
        <span class="hljs-string">&#x27;CREATE TABLE events(ts, msg, PRIMARY KEY(ts, msg))&#x27;</span>)

<span class="hljs-keyword">try</span>:
    <span class="hljs-keyword">with</span> connection:
        connection.executemany(<span class="hljs-string">&#x27;INSERT INTO events VALUES (?, ?)&#x27;</span>, [
            (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;foo&#x27;</span>),
            (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;bar&#x27;</span>),
            (<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;baz&#x27;</span>),
            (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;foo&#x27;</span>),
        ])
<span class="hljs-keyword">except</span> (sqlite3.OperationalError, sqlite3.IntegrityError) <span class="hljs-keyword">as</span> e:
    print(<span class="hljs-string">&#x27;Could not complete operation:&#x27;</span>, e)

<span class="hljs-comment"># No row was inserted because transaction failed</span>
<span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> connection.execute(<span class="hljs-string">&#x27;SELECT * FROM events&#x27;</span>):
    print(row)

connection.close()
</code></pre><h2>Use Pragmas</h2><p>…<em>when it makes sense</em></p><p>There are a few <em>pragmas</em> you can use to tweak the behavior of <code>sqlite3</code> in your program. In particular, one that could improve the performance is <code>synchronous</code>:</p><pre class="code" data-lang="python"><code>connection.execute(<span class="hljs-string">&#x27;PRAGMA synchronous = OFF&#x27;</span>)
</code></pre><p>You should be aware though that this can <em>be dangerous</em>. If the application crashes unexpectedly in the middle of a transaction, the database will probably be left in an inconsistent state. So use with care! But if you want to insert a lot of rows faster, that can be an option. A safer option is to use the <a href="https://www.sqlite.org/draft/wal.html" target="_blank" rel="noopener noreferrer"><code>WAL</code></a> option instead of disabling <code>synchronous</code> completely.</p><pre class="code" data-lang="python"><code>connection.execute(<span class="hljs-string">&#x27;PRAGMA journal_mode = WAL&#x27;</span>)
</code></pre><h2>Postpone Index Creation</h2><p>Let’s say you need a few indices on your database, and you also need to insert a lot of rows while creating them. Postponing the creation of the indices to after all rows have been inserted could result in a substantial performance improvement.</p><h2>Use Placeholders to Interpolate Python Values</h2><p>It is tempting to use Python string operations to include values into queries. <em>Do not</em>! This is highly insecure, and <code>sqlite3</code> gives you a better way to do it:</p><pre class="code" data-lang="python"><code><span class="hljs-comment"># Do not do this!</span>
my_timestamp = <span class="hljs-number">1</span>
c.execute(<span class="hljs-string">&quot;SELECT * FROM events WHERE ts = &#x27;%s&#x27;&quot;</span> % my_timestamp)

<span class="hljs-comment"># Do this instead</span>
my_timestamp = (<span class="hljs-number">1</span>,)
c.execute(<span class="hljs-string">&#x27;SELECT * FROM events WHERE ts = ?&#x27;</span>, my_timestamp)
</code></pre><p>Also, string interpolation using Python <code>%s</code> (or format, or formatted string literals) does not go well with <code>executemany</code>. So there is really no point in trying!</p><hr><p>Keep in mind though that these tips might or might not give you a benefit, depending on your specific use-case. You should always try for yourself and decide if it’s worth it or not.</p><p><em>Edit 28-12-2017</em>: Thanks for all the great feedback from <a href="https://www.reddit.com/r/Python/comments/781q18/getting_the_most_out_of_sqlite3_with_python/" target="_blank" rel="noopener noreferrer">Reddit</a> and <a href="https://news.ycombinator.com/item?id=15525715" target="_blank" rel="noopener noreferrer">Hacker News</a>. I took the liberty to amend the original article with a few of the suggestions.</p><p>There are a few topics that were not mentioned in this article but are definitely worth reading:</p><ul><li><a href="https://docs.python.org/3.6/library/sqlite3.html#controlling-transactions" target="_blank" rel="noopener noreferrer">Using transactions</a> can dramatically improve the speed of your code if you need to run several SQL statements in a row (it should not be needed if you use <code>executemany</code>).</li><li>If you don’t need to re-use your database across sessions, you can use an <a href="https://sqlite.org/inmemorydb.html" target="_blank" rel="noopener noreferrer"><em>in-memory</em></a> database by specifying <code>:memory:</code> as a location, which should give you a nice speed-up.</li><li>You can <a href="https://docs.python.org/3.6/library/sqlite3.html#sqlite3.Connection.row_factory" target="_blank" rel="noopener noreferrer">customize <code>row_factory</code></a> to get something more useful than <code>tuple</code>s as results from <code>SELECT</code> queries.</li><li>Consider changing <code>isolation_level</code> to <code>DEFERRED</code> or <code>IMMEDIATE</code>.</li></ul></div><div class="comments"><span><a class="leave-comment-btn" href="https://github.com/remusao/remusao.github.io/issues/8" title="https://github.com/remusao/remusao.github.io/issues/8" target="_blank" rel="noopener noreferrer">Leave a comment on GitHub</a></span><details><summary>3 comments</summary><ul class="comments-list"><li><div class="comment"><div class="meta"><img loading="lazy" class="avatar" src="https://avatars3.githubusercontent.com/u/875273?v=4" width="40" height="40"> <a class="author" href="https://github.com/bk322" title="bk322" target="_blank" rel="noopener noreferrer">bk322</a> <span>commented </span><a class="date" href="https://github.com/remusao/remusao.github.io/issues/8#issuecomment-425024321" title="https://github.com/remusao/remusao.github.io/issues/8#issuecomment-425024321" target="_blank" rel="noopener noreferrer">2 years ago</a></div><div class="content"><p>How do I execute dot directives:</p><pre data-lang="sql" class="code"><code>.mode csv
.header on

.once "output.csv"

<span class="hljs-keyword">select</span>
  *
<span class="hljs-keyword">from</span> my_table
;
</code></pre><p>I tried to run it via <code>conn.executescript</code> but it doesn’t work.</p></div></div></li><li><div class="comment"><div class="meta"><img loading="lazy" class="avatar" src="https://avatars3.githubusercontent.com/u/875273?v=4" width="40" height="40"> <a class="author" href="https://github.com/bk322" title="bk322" target="_blank" rel="noopener noreferrer">bk322</a> <span>commented </span><a class="date" href="https://github.com/remusao/remusao.github.io/issues/8#issuecomment-425027724" title="https://github.com/remusao/remusao.github.io/issues/8#issuecomment-425027724" target="_blank" rel="noopener noreferrer">2 years ago</a></div><div class="content"><p>Nevermind, seems to be impossible: https://stackoverflow.com/q/2346074/788700</p></div></div></li><li><div class="comment"><div class="meta"><img loading="lazy" class="avatar" src="https://avatars2.githubusercontent.com/u/3480043?v=4" width="40" height="40"> <a class="author" href="https://github.com/Justsoos" title="Justsoos" target="_blank" rel="noopener noreferrer">Justsoos</a> <span>commented </span><a class="date" href="https://github.com/remusao/remusao.github.io/issues/8#issuecomment-597281922" title="https://github.com/remusao/remusao.github.io/issues/8#issuecomment-597281922" target="_blank" rel="noopener noreferrer">4 months ago</a></div><div class="content"><pre data-lang="python" class="code"><code>conn.execute(<span class="hljs-string">'''CREATE TABLE dlt (
    id integer not null primary key autoincrement unique,
    a integer,
    b integer,
    c integer,
    d integer,
    e integer,
    f integer,
    g integer,
    time timestamp default current_timestamp
)'''</span>)
<span class="hljs-comment">####</span>
<span class="hljs-comment"># data is a List of list</span>
conn.executemany(<span class="hljs-string">"INSERT OR IGNORE INTO dlt(id,a,b,c,d,e,f,g) VALUES (?,?,?,?,?,?,?,?)"</span>, [x.split()[<span class="hljs-number">0</span>:<span class="hljs-number">8</span>] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> data])
 
</code></pre><p>a complex use which</p></div></div></li></ul></details></div></article><footer><div class="share"><ul><li><a href="https://www.facebook.com/sharer/sharer.php?u=https://remusao.github.io//posts/few-tips-sqlite-perf.html&t=Getting the most out of SQLite3 with Python" title="Share on Facebook" target="_blank" rel="noopener noreferrer"><img loading="lazy" alt="Share on Facebook" src="/images/social_flat_rounded_rects_svg/Facebook.svg"><a></a></li><li><a href="https://twitter.com/share?url=https://remusao.github.io//posts/few-tips-sqlite-perf.html&text=Getting the most out of SQLite3 with Python&via=Pythux" title="Tweet" target="_blank" rel="noopener noreferrer"><img loading="lazy" alt="Tweet" src="/images/social_flat_rounded_rects_svg/Twitter.svg"><a></a></li><li><a href="https://getpocket.com/save?url=https://remusao.github.io//posts/few-tips-sqlite-perf.html&title=Getting the most out of SQLite3 with Python" title="Add to Pocket" target="_blank" rel="noopener noreferrer"><img loading="lazy" alt="Add to Pocket" src="/images/social_flat_rounded_rects_svg/Pocket.svg"><a></a></li><li><a href="https://news.ycombinator.com/submitlink?u=https://remusao.github.io//posts/few-tips-sqlite-perf.html&t=Getting the most out of SQLite3 with Python" title="Submit to Hacker News" target="_blank" rel="noopener noreferrer"><img loading="lazy" alt="Submit to Hacker News" src="/images/social_flat_rounded_rects_svg/HackerNews.svg"><a></a></li><li><a href="https://www.reddit.com/submit?url=https://remusao.github.io//posts/few-tips-sqlite-perf.html&title=Getting the most out of SQLite3 with Python" title="Submit to Reddit" target="_blank" rel="noopener noreferrer"><img loading="lazy" alt="Submit to Reddit" src="/images/social_flat_rounded_rects_svg/Reddit.svg"><a></a></li></ul></div></footer></main></body></html>