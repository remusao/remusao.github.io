<!DOCTYPE html><html lang="fr" dir="ltr"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>Crible d'Ératosthène, Un algo pour les trouver tous</title><meta name="description" content="Simplex Sigillum Veri"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="canonical" href="https://remusao.github.io/posts/eratosthene-algo-to-find-them-all.html"><link rel="icon" type="image/x-icon" href="/images/favicon.ico"><style type="text/css">@font-face{font-display:swap;font-family:'Open Sans';font-style:italic;font-weight:400;src:url(/fonts/OpenSans_italic_400.woff2) format('woff2')}@font-face{font-display:swap;font-family:'Open Sans';font-style:italic;font-weight:700;src:url(/fonts/OpenSans_italic_700.woff2) format('woff2')}@font-face{font-display:swap;font-family:'Open Sans';font-style:normal;font-weight:400;src:url(/fonts/OpenSans_normal_400.woff2) format('woff2')}@font-face{font-display:swap;font-family:'Open Sans';font-style:normal;font-weight:700;src:url(/fonts/OpenSans_normal_700.woff2) format('woff2')}body{color:#2f2f2f;font-family:'Open Sans',sans-serif;font-size:95%;line-height:1.6em;margin:20px auto;max-width:42em;padding:0 1em}@media (min-width:760px){body{font-size:100%}}@media (min-width:1024px){body{font-size:105%}}h1,h2,h3{font-size:1.7em;font-weight:400;padding-top:.7em}h2,h3{font-size:1.5em}h3{font-size:1.2em}.header,.main figcaption{color:#555;font-style:italic}.main a{color:#3465a4}.main a:visited{color:#75507b}.main figcaption{color:#696f72;line-height:2em;text-align:center}.main img{display:block;height:auto;margin:auto;padding-bottom:1em;padding-top:1em;width:90%}.main blockquote{border-left:thin solid #d3d7cf;color:#555;margin:10px;padding:0 0 0 1em}@font-face{font-display:swap;font-family:'Inconsolata';font-style:normal;font-weight:400;src:url(/fonts/Inconsolata.woff2) format('truetype')}code{background-color:#f3f4f5;font-family:'Inconsolata';line-height:1.2em}pre code{display:block;overflow-x:auto;padding:8px}.leave-comment-btn,summary{font-size:15px;font-weight:600}.leave-comment-btn{background-color:#28a745;background-image:linear-gradient(-180deg,#34d058,#28a745 90%);border:1px solid rgba(27,31,35,.2);border-radius:.25em;color:#fff;display:inline-block;margin-top:1.5em;padding:3px 10px;text-decoration:none}.leave-comment-btn:hover{box-shadow:0 1px 3px rgba(0,0,0,.24)}summary{color:#516ae8;cursor:pointer;line-height:1.2rem;margin-top:2rem}.comments-list{list-style:none;padding:0}.comment{background-color:#fff;border:1px solid #d1d5da;border-radius:3px;color:#24292e;font-size:15px;margin:1em 0}.meta{background-color:#f6f8fa;border-bottom:1px solid #d1d5da;color:#586069}.author,.date{text-decoration:none}.author{color:#24292e!important;font-weight:700}.date{color:#586069}.date:hover{color:#0366d6}.content{padding-left:20px}.avatar,.emoji{vertical-align:middle}.avatar{display:inline-block;margin-right:5px}.emoji{height:1.1em;width:1.1em}table{border-collapse:collapse;margin:auto}td,th{border:1px solid #ddd;padding:10px}tr:hover{background-color:#f5f5f5}footer{border-top:thin solid #d3d7cf;margin:1.5em 0}.share ul{text-align:right}.share li{display:inline;padding:0 5px}.share img{width:2em}.main a,header a{text-decoration:none}.hljs{display:block;overflow-x:auto;padding:.5em;color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag{color:#333;font-weight:700}.hljs-subst{color:#333}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style></head><body><main><header><h1><a href="../"><span>../</span></a></h1></header><h1>Crible d'Ératosthène, Un algo pour les trouver tous</h1><section class="header"><div>2011-11-15 | <em>Reading time: ~8 minutes</em></div></section><article><div class="main"><p>Il y a quelques temps je me suis intéressé au crible d’Ératosthène, qui permet de trouver l’ensemble des nombres premiers inférieurs à une borne donnée. L’application naïve de l’algorithme dans sa version originale n’étant pas très performante, j’ai cherché à l’optimiser afin d’obtenir des performances correctes. Voici donc les différents moyens de rendre cet algorithme plus efficace. Des fichiers sources en C ou en Python seront fournis tout au long de l’article.</p><ol><li>Qu’est-ce qu’un nombre premier ?</li><li>Le crible d’Ératosthène.</li><li>Optimisations.</li><li>Performances.</li><li>Conclusion.</li></ol><p><em>Qu’est-ce qu’un nombre premier</em> – Un nombre premier est un entier naturel qui n’admet que deux diviseurs, 1 et lui-même. Ce qui exclut tous les autres entiers naturels (c’est sur cette remarque qu’est basé le crible d’Ératosthène). Il existe une infinité de nombre premiers.</p><p><em>Le crible d’Ératosthène</em> – L’algorithme du crible d’Ératosthène est très simple. Prenons un tableau contenant les entiers de 2 a n (si l’on désire connaitre tous les nombres premiers inférieurs à n) que l’on suppose tous premiers. Ensuite il suffit, pour chaque élément du tableau, de supprimer tous ses multiples. Le pseudo code pourrait donc être le suivant :</p><pre><code class="language-python">Crible(entier n):
  Tableau = entiers de <span class="hljs-number">2</span> a n
  Pour chaque i dans Tableau
    supprimer_multiples de i dans Tableau
  Fin Pour Fin Crible</code></pre><p>Le pseudo-code suivant peut aisément être implémenté en Python :</p><pre><code class="language-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Supprimer_multiples</span>(<span class="hljs-params">i, tableau</span>):</span>
  <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> tableau:
    <span class="hljs-keyword">if</span> x &gt; i <span class="hljs-keyword">and</span> x % i == <span class="hljs-number">0</span>:
      tableau.remove(x)

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Crible</span>(<span class="hljs-params">n</span>):</span>
  tableau = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>, n)]
  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> tableau:
    Supprimer_multiples(i, tableau)
  <span class="hljs-keyword">return</span> tableau

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span>
  tableau = Crible(<span class="hljs-number">100</span>)
  <span class="hljs-keyword">print</span> tableau

main()</code></pre><p>On remarque que la complexité de cette implémentation n’est pas du tout adaptée à des <code>n</code> très grands (essayez avec <code>n &gt; 10000</code>, le résultat va commencer à mettre un certain temps à être calculé). Voyons comment l’optimiser.</p><h2 id="optimisations">Optimisations</h2><p><em>Première remarque</em>, si le fait de stocker tous les nombres dans un tableau puis de les supprimer au fur et à mesure peut sembler plus lisible, ce n’est pas une bonne méthode si l’on recherche les performances. Une première optimisation est de déclarer un tableau de n cases qui peuvent chacune contenir soit 1 soit 0 en fonction de la primalité (ou non-primalité) du nombre correspondant à l’index considéré dans le tableau. Nous allons voir qu’avec cette technique nous allons pouvoir nous passer complètement de comparaisons et de tests (sauf pour les cas d’arrêt des boucles bien évidemment), ce qui va diminuer grandement le temps de calcul.</p><p><em>Deuxièmement</em>, on remarque que pour obtenir tous les multiples d’un nombre i dans notre tableau dont les index correspondent aux nombres dont on veut connaitre la primalité, il n’est pas nécessaire de parcourir tout le tableau en testant à chaque fois le modulo. Pour cela il suffit de partir de l’index i puis d’aller de i en i dans le tableau, nous sommes ainsi assurés de passer sur tous les multiples de i (y compris lui-même). Ceci va grandement améliorer notre algorithme.</p><p>Une autre remarque que l’on peut faire est que pour tester la primalité d’un nombre n, il n’est pas nécessaire de tester la division par tous les nombres de <code>2</code> a <code>n</code>, il suffit d’aller jusqu’à la racine carrée de n (au delà on ne peut pas trouver de diviseur entier).</p><p>Enfin, une petite amélioration liée à l’implémentation en C de l’algorithme, puisqu’on va devoir initialiser notre tableau avec toutes les cases à 1, autant éliminer tous les nombres pairs (qui ne sont pas premier puisque divisibles par <code>2</code>). On peut donc initialiser notre tableau avec deux boucles distinctes, une qui part de 3 et qui va jusqu’à n de deux en deux en initialisant à 1 les cases visitées et une autre qui part de 4 et qui va jusqu’à n de deux en deux en initialisant à 0 les cases parcourues. Voici ce que donne l’algorithme implémenté en C avec les optimisations précédentes (sources : <a href="http://www.pythux.com/exemples/erato/crible_1.c">http://www.pythux.com/exemples/erato/crible_1.c</a>). Pour compiler le fichier source, vous pouvez utiliser soit clang soit gcc (ou un autre compilateur C) comme ceci :</p><pre><code class="language-sh">clang -lm -O3 crible_1.c
gcc -lm -o3 crible_1.c</code></pre><p>Nous pourrions nous arrêter là, puisque les performances sont déjà très bonnes (11 ms pour un crible jusqu’à 1.000.000 et 40-45 secondes jusqu’à 1.000.000.000), mais nous allons voir qu’il est encore possible de diminuer drastiquement le temps de calcul. En effet, nous savons qu’à part le nombre 2, aucun nombre pair n’est premier. Nous pourrions donc chercher un moyen de ne pas les stocker dans le tableau, afin de ne garder que les nombres impairs. Nous diviserions donc dans un premier temps l’espace mémoire occupé par deux. Pour un crible jusqu’à n = 30, nous aurions à stocker les éléments suivants :</p><pre><code class="language-sh">Les nombres -&gt; [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29]
Les index   -&gt; [0, 1, 2, 3, 4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14]</code></pre><p>Hors, nous ne pouvons plus simplement utiliser les index dans le tableau pour connaitre les nombres associés. En fait, on peut remarquer que pour retrouver le nombre associé a chaque case du tableau, il nous suffit de calculer : <code>index * 2 + 1</code> . Deuxièmement, pour retrouver les multiples d’un nombre N dans le tableau, il nous suffit d’aller de N en N dans le tableau en partant de la case <code>N / 2</code>. Enfin, on remarque qu’avec cette technique, l’algorithme est plus compact et nous pouvons nous contenter d’initialiser toutes les cases du tableau à 1 (avec la fonction memset de la bibliothèque <code>&lt;string&gt;</code> du langage C). Voici le code source de cette implémentation (sources : <a href="http://www.pythux.com/exemples/erato/crible.c">http://www.pythux.com/exemples/erato/crible.c</a>) :</p><pre><code class="language-c"><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">erato_opti</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span>
</span>{
  <span class="hljs-keyword">char</span>  *tab = <span class="hljs-built_in">malloc</span>(n / <span class="hljs-number">2</span>);
  <span class="hljs-keyword">int</span>   i = <span class="hljs-number">1</span>, j, borne = <span class="hljs-built_in">sqrt</span>(n / <span class="hljs-number">2</span>), step;

  tab = <span class="hljs-built_in">memset</span>(tab, <span class="hljs-number">1</span>, n / <span class="hljs-number">2</span>);

  <span class="hljs-keyword">for</span> (; i &lt;= borne; i++)
  {
    step = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>;
    <span class="hljs-keyword">for</span> (j = i + step; j &lt; n / <span class="hljs-number">2</span>; j += step)
      tab[j] = <span class="hljs-number">0</span>;
  }

  <span class="hljs-keyword">return</span> (tab);
}</code></pre><p>Si nous voulons afficher les nombres premiers produits par la fonction erato_opti il nous suffit d’utiliser l’astuce du <code>nombre = index * 2 + 1</code> et de ne pas oublier d’afficher le nombre 2 (qui n’est pas contenu dans le tableau) :</p><pre><code class="language-c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print_erato_space</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *tab, <span class="hljs-keyword">int</span> n)</span>
</span>{
  <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;

  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"2\n"</span>);
  <span class="hljs-keyword">for</span> (; i &lt; n / <span class="hljs-number">2</span>; i++)
    <span class="hljs-keyword">if</span> (tab[i])
      <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%i\n"</span>, i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);
}</code></pre><p>Vous pouvez compiler les sources précédentes avec l’une ou l’autre des commandes suivantes :</p><pre><code class="language-sh">clang -lm -O3 crible.c
gcc -lm -O3 crible.c</code></pre><h2 id="performances">Performances</h2><p>Voici un récapitulatif des performances obtenues avec les différentes implémentations :</p><table><thead><tr><th>Valeur de N</th><th align="center">1000</th><th align="center">10.000</th><th align="center">1.000.000</th><th align="center">1.000.000.000</th></tr></thead><tbody><tr><td>Version Python (Pypy)</td><td align="center">30ms</td><td align="center">370ms</td><td align="center">/</td><td align="center">/</td></tr><tr><td>Version Python (CPython)</td><td align="center">42ms</td><td align="center">710ms</td><td align="center">/</td><td align="center">/</td></tr><tr><td>Version C intermédiaire</td><td align="center">1ms</td><td align="center">1ms</td><td align="center">7ms</td><td align="center">40s</td></tr><tr><td>Version C opti</td><td align="center">1ms</td><td align="center">1ms</td><td align="center">6ms</td><td align="center">32s</td></tr></tbody></table><h2 id="conclusion">Conclusion</h2><p>Nous avons vu quelques optimisations possibles sur l’algorithme du crible d’Ératosthène. Cet article est loin d’être exhaustif, vous pourrez trouver d’autres optimisations plus ou moins efficaces. Néanmoins, la plupart des implémentations trouvables sur internet et qui sont plus performante que celle proposée ici sont moins lisibles et plus complexes que celle-ci (qui ne fait qu’une dizaine de ligne). Si vous connaissez d’autres optimisations, n’hésitez pas a poster un commentaire :)</p></div><div class="comments"></div></article><footer><div class="share"><ul><li><a href="https://www.facebook.com/sharer/sharer.php?u=https://remusao.github.io//posts/eratosthene-algo-to-find-them-all.html&t=Crible d'Ératosthène, Un algo pour les trouver tous" title="Share on Facebook" target="_blang" rel="noopener noreferrer"><img loading="lazy" alt="Share on Facebook" src="/images/social_flat_rounded_rects_svg/Facebook.svg"><a></a></li><li><a href="https://twitter.com/share?url=https://remusao.github.io//posts/eratosthene-algo-to-find-them-all.html&text=Crible d'Ératosthène, Un algo pour les trouver tous&via=Pythux" title="Tweet" target="_blang" rel="noopener noreferrer"><img loading="lazy" alt="Tweet" src="/images/social_flat_rounded_rects_svg/Twitter.svg"><a></a></li><li><a href="https://getpocket.com/save?url=https://remusao.github.io//posts/eratosthene-algo-to-find-them-all.html&title=Crible d'Ératosthène, Un algo pour les trouver tous" title="Add to Pocket" target="_blang" rel="noopener noreferrer"><img loading="lazy" alt="Add to Pocket" src="/images/social_flat_rounded_rects_svg/Pocket.svg"><a></a></li><li><a href="https://news.ycombinator.com/submitlink?u=https://remusao.github.io//posts/eratosthene-algo-to-find-them-all.html&t=Crible d'Ératosthène, Un algo pour les trouver tous" title="Submit to Hacker News" target="_blang" rel="noopener noreferrer"><img loading="lazy" alt="Submit to Hacker News" src="/images/social_flat_rounded_rects_svg/HackerNews.svg"><a></a></li><li><a href="https://www.reddit.com/submit?url=https://remusao.github.io//posts/eratosthene-algo-to-find-them-all.html&title=Crible d'Ératosthène, Un algo pour les trouver tous" title="Submit to Reddit" target="_blang" rel="noopener noreferrer"><img loading="lazy" alt="Submit to Reddit" src="/images/social_flat_rounded_rects_svg/Reddit.svg"><a></a></li></ul></div></footer></main></body></html>