<!DOCTYPE html><html lang="en" dir="ltr"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>The Wrong Way of Benchmarking Integer Comparison Functions</title><meta name="description" content="Simplex Sigillum Veri"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="canonical" href="https://remusao.github.io/posts/wrong-way-benchmarking-integer-comparison.html"><link rel="icon" type="image/x-icon" href="/images/favicon.ico"><style type="text/css">@font-face{font-display:swap;font-family:'Open Sans';font-style:italic;font-weight:400;src:url(/fonts/OpenSans_italic_400.woff2) format('woff2')}@font-face{font-display:swap;font-family:'Open Sans';font-style:italic;font-weight:700;src:url(/fonts/OpenSans_italic_700.woff2) format('woff2')}@font-face{font-display:swap;font-family:'Open Sans';font-style:normal;font-weight:400;src:url(/fonts/OpenSans_normal_400.woff2) format('woff2')}@font-face{font-display:swap;font-family:'Open Sans';font-style:normal;font-weight:700;src:url(/fonts/OpenSans_normal_700.woff2) format('woff2')}body{color:#2f2f2f;font-family:'Open Sans',sans-serif;font-size:95%;line-height:1.6em;margin:20px auto;max-width:42em;padding:0 1em}@media (min-width:760px){body{font-size:100%}}@media (min-width:1024px){body{font-size:105%}}h1,h2,h3{font-size:1.7em;font-weight:400;padding-top:.7em}h2,h3{font-size:1.5em}h3{font-size:1.2em}.header,.main figcaption{color:#555;font-style:italic}.main a{color:#3465a4}.main a:visited{color:#75507b}.main figcaption{color:#696f72;line-height:2em;text-align:center}.main img{display:block;height:auto;margin:auto;padding-bottom:1em;padding-top:1em;width:90%}.main blockquote{border-left:thin solid #d3d7cf;color:#555;margin:10px;padding:0 0 0 1em}@font-face{font-display:swap;font-family:'Inconsolata';font-style:normal;font-weight:400;src:url(/fonts/Inconsolata.woff2) format('truetype')}code{background-color:#f3f4f5;font-family:'Inconsolata';line-height:1.2em}pre code{display:block;overflow-x:auto;padding:8px}.leave-comment-btn,summary{font-size:15px;font-weight:600}.leave-comment-btn{background-color:#28a745;background-image:linear-gradient(-180deg,#34d058,#28a745 90%);border:1px solid rgba(27,31,35,.2);border-radius:.25em;color:#fff;display:inline-block;margin-top:1.5em;padding:3px 10px;text-decoration:none}.leave-comment-btn:hover{box-shadow:0 1px 3px rgba(0,0,0,.24)}summary{color:#516ae8;cursor:pointer;line-height:1.2rem;margin-top:2rem}.comments-list{list-style:none;padding:0}.comment{background-color:#fff;border:1px solid #d1d5da;border-radius:3px;color:#24292e;font-size:15px;margin:1em 0}.meta{background-color:#f6f8fa;border-bottom:1px solid #d1d5da;color:#586069}.author,.date{text-decoration:none}.author{color:#24292e!important;font-weight:700}.date{color:#586069}.date:hover{color:#0366d6}.content{padding-left:20px}.avatar,.emoji{vertical-align:middle}.avatar{display:inline-block;margin-right:5px}.emoji{height:1.1em;width:1.1em}table{border-collapse:collapse;margin:auto}td,th{border:1px solid #ddd;padding:10px}tr:hover{background-color:#f5f5f5}footer{border-top:thin solid #d3d7cf;margin:1.5em 0}.share ul{text-align:right}.share li{display:inline;padding:0 5px}.share img{width:2em}.main a,header a{text-decoration:none}.hljs{display:block;overflow-x:auto;padding:.5em;color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag{color:#333;font-weight:700}.hljs-subst{color:#333}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style></head><body><main><header><h1><a href="../"><span>../</span></a></h1></header><h1>The Wrong Way of Benchmarking Integer Comparison Functions</h1><section class="header"><div>2017-11-25 | <em>Reading time: ~3 minutes</em></div></section><article><div class="main"><p><em>TL;DR</em>: Naive code can sometimes run faster than “clever” code. Compilers are usually designed to optimize for the most common code, and common code is not clever. Lessons learned; if you try to write clever code, benchmark it to make sure there is a benefit.</p><p>I recently stumbled upon <a href="https://blogs.msdn.microsoft.com/oldnewthing/20171117-00/?p=97416">an article</a>, describing how trying to out-smart the compiler can result in bad performances compared to more naive code. The benchmark is about finding the most efficient way to write a comparison function between integers, to be used in conjunction with <code>sort</code> or binary search for example. The original post being about <code>c++</code>, I was curious to know if the results would transfer to JavaScript (in particular <code>V8</code>, using <code>Node.js</code>). This is what this post is about.</p><p>Let see the contenders:</p><ul><li><em>Naive</em></li></ul><pre><code class="language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compare1</span>(<span class="hljs-params">a, b</span>) </span>{
    <span class="hljs-keyword">if</span> (a &lt; b) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    <span class="hljs-keyword">if</span> (a &gt; b) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre><ul><li><em>Clever</em></li></ul><pre><code class="language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compare2</span>(<span class="hljs-params">a, b</span>) </span>{
    <span class="hljs-keyword">return</span> a - b;
}</code></pre><h2 id="benchmarks">Benchmarks</h2><p>The original article has a very good point saying that to benchmark this code realistically, you need a real use-case. Just sorting the array and summing the numbers does not make any sense, no one would do it. But if instead you perform a binary search on the sorted array, it gets closer to something one might do in a real code-base.</p><p>I took the liberty of converting the original <code>C++</code> implementation of the binary search into JavaScript, to stick closely to the article:</p><pre><code class="language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">binarySearch</span>(<span class="hljs-params">array, first, last, key, compare</span>) </span>{
  <span class="hljs-keyword">var</span> length = last - first;
  <span class="hljs-keyword">while</span> (length &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">var</span> step = (length / <span class="hljs-number">2</span>) | <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> middle = first + step;
    <span class="hljs-keyword">var</span> result = compare(array[middle], key);
    <span class="hljs-keyword">if</span> (result &lt; <span class="hljs-number">0</span>) {
      first = middle + <span class="hljs-number">1</span>;
      length -= step + <span class="hljs-number">1</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result === <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">return</span> middle;
    } <span class="hljs-keyword">else</span> {
      length = step;
    }
  }

  <span class="hljs-keyword">return</span> last;
}</code></pre><p>Using the great <a href="https://www.npmjs.com/package/benchmark">benchmark</a> library, let’s evaluate the performance of each compare function:</p><ul><li><em>Setup</em></li></ul><pre><code class="language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span>(<span class="hljs-params">compare</span>) </span>{
  <span class="hljs-comment">// Create a sorted array</span>
  <span class="hljs-keyword">var</span> array = [];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8192</span>; ++i) {
    array.push(i * <span class="hljs-number">2</span>);
  }

  <span class="hljs-keyword">var</span> found = <span class="hljs-number">0</span>;

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">-1</span>; j &lt; <span class="hljs-number">16383</span>; ++j) {
    <span class="hljs-keyword">var</span> index = binarySearch(
      array,              <span class="hljs-comment">// sorted array</span>
      <span class="hljs-number">0</span>,                  <span class="hljs-comment">// start index</span>
      array.length - <span class="hljs-number">1</span>,   <span class="hljs-comment">// end index</span>
      j,                  <span class="hljs-comment">// element we are looking for</span>
      compare);           <span class="hljs-comment">// comparison function</span>

    <span class="hljs-keyword">if</span> (index !== <span class="hljs-number">-1</span> &amp;&amp; array[index] === j) {
      found += <span class="hljs-number">1</span>;
    }
  }

  <span class="hljs-keyword">if</span> (found !== <span class="hljs-number">8191</span>) {
    <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'Found bug'</span>, found);
  }
}</code></pre><ul><li><em>Benchmark</em></li></ul><pre><code class="language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bench</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> Benchmark = <span class="hljs-built_in">require</span>(<span class="hljs-string">'benchmark'</span>);
  <span class="hljs-keyword">var</span> suite = <span class="hljs-keyword">new</span> Benchmark.Suite();

  suite
    .add(<span class="hljs-string">'compare1'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      run(compare1);
    })
    .add(<span class="hljs-string">'compare2'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      run(compare2);
    })
    .on(<span class="hljs-string">'cycle'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>{
      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">String</span>(event.target));
    })
    .on(<span class="hljs-string">'complete'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Fastest is '</span> + <span class="hljs-keyword">this</span>.filter(<span class="hljs-string">'fastest'</span>).map(<span class="hljs-string">'name'</span>));
    })
    .run({});
}

bench();</code></pre><p>And…</p><blockquote><pre><code class="language-sh">compare1 x 421 ops/sec ±0.51% (91 runs sampled)
compare2 x 394 ops/sec ±0.39% (89 runs sampled)</code></pre></blockquote><p>It happens that the naive <code>compare1</code> is a bit faster than <code>compare2</code>. It’s not day and night, but the <em>naive</em>, more readable code is more efficient on V8 than the clever one.</p><p>The complete version of the code used in this <a href="/snippets/compare-benchmark.js">available there</a></p></div><div class="comments"><span><a class="leave-comment-btn" href="https://github.com/remusao/remusao.github.io/issues/4" title="https://github.com/remusao/remusao.github.io/issues/4" target="_blank" rel="noopener noreferrer">Leave a comment on GitHub</a></span></div></article><footer><div class="share"><ul><li><a href="https://www.facebook.com/sharer/sharer.php?u=https://remusao.github.io//posts/wrong-way-benchmarking-integer-comparison.html&t=The Wrong Way of Benchmarking Integer Comparison Functions" title="Share on Facebook" target="_blang" rel="noopener noreferrer"><img loading="lazy" alt="Share on Facebook" src="/images/social_flat_rounded_rects_svg/Facebook.svg"><a></a></li><li><a href="https://twitter.com/share?url=https://remusao.github.io//posts/wrong-way-benchmarking-integer-comparison.html&text=The Wrong Way of Benchmarking Integer Comparison Functions&via=Pythux" title="Tweet" target="_blang" rel="noopener noreferrer"><img loading="lazy" alt="Tweet" src="/images/social_flat_rounded_rects_svg/Twitter.svg"><a></a></li><li><a href="https://getpocket.com/save?url=https://remusao.github.io//posts/wrong-way-benchmarking-integer-comparison.html&title=The Wrong Way of Benchmarking Integer Comparison Functions" title="Add to Pocket" target="_blang" rel="noopener noreferrer"><img loading="lazy" alt="Add to Pocket" src="/images/social_flat_rounded_rects_svg/Pocket.svg"><a></a></li><li><a href="https://news.ycombinator.com/submitlink?u=https://remusao.github.io//posts/wrong-way-benchmarking-integer-comparison.html&t=The Wrong Way of Benchmarking Integer Comparison Functions" title="Submit to Hacker News" target="_blang" rel="noopener noreferrer"><img loading="lazy" alt="Submit to Hacker News" src="/images/social_flat_rounded_rects_svg/HackerNews.svg"><a></a></li><li><a href="https://www.reddit.com/submit?url=https://remusao.github.io//posts/wrong-way-benchmarking-integer-comparison.html&title=The Wrong Way of Benchmarking Integer Comparison Functions" title="Submit to Reddit" target="_blang" rel="noopener noreferrer"><img loading="lazy" alt="Submit to Reddit" src="/images/social_flat_rounded_rects_svg/Reddit.svg"><a></a></li></ul></div></footer></main></body></html>