<!DOCTYPE html><html lang="en" dir="ltr"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>Thoughts About Unit and Integration Tests</title><meta name="description" content="Simplex Sigillum Veri"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="canonical" href="https://remusao.github.io/posts/unit-integration-tests.html"><link rel="icon" type="image/x-icon" href="/images/favicon.ico"><style type="text/css">body{color:#2f2f2f;font-family:'Palatino Linotype',Palatino,Palladio,'URW Palladio L','Book Antiqua',Baskerville,'Bookman Old Style','Bitstream Charter','Nimbus Roman No9 L',Garamond,'Apple Garamond','ITC Garamond Narrow','New Century Schoolbook','Century Schoolbook','Century Schoolbook L',Georgia,serif;font-size:18px;line-height:1.6em;margin:20px auto;max-width:40rem;padding:0 1.5em;text-rendering:optimizeLegibility}h1,h2,h3{padding-top:.7em}.header,.main figcaption{color:#555;font-style:italic}.main a{color:#3465a4}.main a:visited{color:#75507b}.main figcaption{color:#696f72;line-height:2em;text-align:center}.main img{display:block;height:auto;margin:auto;padding-bottom:1em;padding-top:1em;width:90%}.main blockquote{border-left:thin solid #d3d7cf;color:#555;margin:10px;padding:0 0 0 1em}code{background-color:#f3f4f5;font-family:Consolas,'Andale Mono WT','Andale Mono','Lucida Console','Lucida Sans Typewriter','DejaVu Sans Mono','Bitstream Vera Sans Mono','Liberation Mono','Nimbus Mono L',Monaco,'Courier New',Courier,monospace;font-size:14px;line-height:1.2em}pre code{display:block;overflow-x:auto;padding:8px}.leave-comment-btn,summary{font-size:16px;font-weight:600}.leave-comment-btn{background-color:#28a745;background-image:linear-gradient(-180deg,#34d058,#28a745 90%);border:1px solid rgba(27,31,35,.2);border-radius:.25em;color:#fff;display:inline-block;margin-top:1.5em;padding:3px 10px;text-decoration:none}.leave-comment-btn:hover{box-shadow:0 1px 3px rgba(0,0,0,.24)}summary{color:#516ae8;cursor:pointer;line-height:1.2rem;margin-top:2rem}.comments-list{list-style:none;padding:0}.comment{background-color:#fff;border:1px solid #d1d5da;border-radius:3px;color:#24292e;font-size:16px;margin:1em 0}.meta{background-color:#f6f8fa;border-bottom:1px solid #d1d5da;color:#586069}.author,.date{text-decoration:none}.author{color:#24292e!important;font-weight:700}.date{color:#586069}.date:hover{color:#0366d6}.content{padding-left:20px}.avatar,.emoji{vertical-align:middle}.avatar{display:inline-block;margin-right:5px}.emoji{height:1.1em;width:1.1em}table{border-collapse:collapse;margin:auto}td,th{border:1px solid #ddd;padding:10px}tr:hover{background-color:#f5f5f5}footer{border-top:thin solid #d3d7cf;margin:1.5em 0}.share ul{text-align:right}.share li{display:inline;padding:0 5px}.share img{width:2em}.main a,header a{text-decoration:none}.hljs{display:block;overflow-x:auto;padding:.5em;color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag{color:#333;font-weight:700}.hljs-subst{color:#333}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style></head><body><main><header><h1><a href="../"><span>../</span></a></h1></header><h1>Thoughts About Unit and Integration Tests</h1><section class="header"><div>2019-10-26 | <em>Reading time: ~7 minutes</em></div></section><article><div class="main"><blockquote><p>Do not feed the anti-patterns!</p></blockquote><p>I recently found myself working with tests—integration and unit—. This experience led to some frustration, which got me thinking… Where did the frustration come from? How could it be done differently? And ultimately, what makes a good test? This post is a collection of thoughts about testing, not an exhaustive guide.</p><h2 id="unit-vs-integration">Unit vs. Integration?</h2><blockquote><p>It does not matter which one you pick first, you might need both eventually…</p></blockquote><p>Before writing any test, you might be wondering <em>which kind of test</em> makes sense. Would it be better to cover your new feature with unit or integration tests? You might want to pause for a moment and think about the trade-offs of the different options.</p><p>Often, <em>unit tests</em> will run in a more controlled environment, maybe with some dependencies <a href="https://en.wikipedia.org/wiki/Mock_object">mocked</a>, so that you can focus on a specific file, class or function. This means that unit tests are more targeted than integration tests. It also means that they might be easier to reason about, and quicker to iterate with. As an example, imagine testing a JavaScript library; unit tests could be running in Node.js instead of a full-blown browser.</p><p>On the other hand, <em>integration tests</em> will potentially target multiple systems interacting with each other, running in an environment which is much closer to production conditions. Using the same example, your JavaScript library might now be tested in a handful of browsers (e.g.: Firefox, Chromium and Safari, with different versions of each), while interacting with other libraries. This means that you will most likely gain more confidence that the code works in production environment, at the cost of a more complex setup.</p><h2 id="non-regression-tests">Non-regression Tests</h2><blockquote><p>Non-regression is not the same as <em>non-evolution</em>.</p></blockquote><p>It is desirable to consolidate APIs or components with non-regression tests, but be careful not to prevent future evolution! This might happen if you take the current production system and generate test-cases by feeding inputs, getting the results and writing high-level tests which ensure that the output is always the one that was expected <em>at the time test-cases were generated</em>.</p><p>Although this might feel good at first—we have great test coverage after all!—, this approach has at least one major short-coming: <em>it’s very hard to make the tests evolve in the future*. It’s nice to “freeze” the capabilities of your system with numerous tests, but unless said system is not meant to evolve in the future, the assumptions about expected results will most likely evolve over time. This means that when writing tests you probably need to think not only about coverage and the expected behavior *right now</em>, but also how easy it will be to make the tests evolve in the future.</p><p>Tests are tightly related to the code being tested and, if you are not careful, rigid tests might make changing the source code much more painful than it should be.</p><h2 id="your-tests-are-code">Your Tests are Code</h2><blockquote><p>Tests are not the destination, they are the starting point and the path.</p></blockquote><p>There is a misunderstanding at the root of all evils: you shall not <em>treat your tests differently than your source code<em>. Tests **are</em></em> code! To make things a bit more concrete, here is a list of assumptions which I think are reasonable when it comes to source code but are rarely accepted for tests:</p><ul><li>You expect to be able to <em>build</em> and <em>run</em> your code easily.</li><li>You expect your code to be <em>efficient</em>.</li><li>You expect your code to be <em>understandable</em>.</li><li>You expect your code to be <em>documented</em>.</li><li>You expect your code to be <em>cross-platform</em>.</li><li>You expect your code to be <em>easy to delete</em>!</li><li>You expect your code to <em>not be redundant and use abstractions</em>.</li></ul><p>Whenever one of the expectations holds for your code, try replacing <code>code</code> with <code>tests</code> and ask yourself if it is still true. Your code and the tests you write to ensure it behaves in a correct way will have to evolve side-by-side in the future. You do not want your tests to become a <em>liability</em>.</p><h2 id="future-proof-tests">Future-Proof Tests?</h2><blockquote><p>No developer ever reads the same code twice. — Heraclitus</p></blockquote><p>When writing tests, try to express your intent and give cues to the future reader —that might be you in a few months!— regarding why a given assertion was needed, what behavior is being tested, etc. Alongside the usual features of a language such as <em>comments</em>, <em>good names</em> for variables and functions, etc. modern testing frameworks give many tools to ease this process: use things like <code>describe(...)</code>, <code>it(...)</code> and explicit assertions <code>expect(...).to.be</code>.</p><p>Additionally, as a contributor to a project which has tests, it should be reasonnably straightforward to answer the following questions:</p><ul><li>when looking at code, where can I find the existing tests?</li><li>when looking at tests, which code is being tested?</li></ul><p>There should be a clear path to modify both code and tests:</p><ul><li>when changing code, which tests need to be changed?</li><li>when deleting code, which tests need to be deleted?</li></ul><p>A few tips can ease this process. <em>Naming conventions</em> for test files should be consistent and finding the tests for a given file or component should not involve any interpretation, it should be mechanical (e.g.: tests for <code>module.js</code> are always to be found in <code>tests/module.test.js</code>).</p><p>Tests should be organized in a way that follows the code structure closely so that changes in the source can be reflected to the tests and <em>vice versa</em>. This also applies to the internal structure of the tests. It can be helpful to group assertions by behavior or assumptions. It is also helpful to be explicit about both success and failure of an assertion!</p><p>This last point is important because if you can quickly grasp the intent while reading a test; it allows to decide if an assertion still holds after a change in the code, or if it should go away completely.</p><p>Last but not least, avoid repetition in tests. If you see yourself writing the same assertions over and over again to tests similar components, it might be worth abstracting these away. You will thank yourself in the future when you need to amend the tests!</p><h2 id="by-way-of-conclusion">By Way of Conclusion</h2><blockquote><p>Always pick the right hammer for your nails…</p></blockquote><p>As mentioned previously, this is not about picking unit tests over integration tests. You will likely need both eventually because they are often complementary and give you a different kind of confidence in the correctness of your code (although some <a href="https://blog.thecodewhisperer.com/permalink/integrated-tests-are-a-scam">argue against integration tests</a>).</p><p>As a take-away, treat your tests the same way you treat your source code and hold them both to high standards. Not doing so might lead to a situation where your tests become a liability and slow you down instead of empowering you to write better and more robust features.</p></div><div class="comments"><span><a class="leave-comment-btn" href="https://github.com/remusao/remusao.github.io/issues/44" title="https://github.com/remusao/remusao.github.io/issues/44" target="_blank" rel="noopener noreferrer">Leave a comment on GitHub</a></span></div></article><footer><div class="share"><ul><li><a href="https://www.facebook.com/sharer/sharer.php?u=https://remusao.github.io//posts/unit-integration-tests.html&t=Thoughts About Unit and Integration Tests" title="Share on Facebook" target="_blank" rel="noopener noreferrer"><img loading="lazy" alt="Share on Facebook" src="/images/social_flat_rounded_rects_svg/Facebook.svg"><a></a></li><li><a href="https://twitter.com/share?url=https://remusao.github.io//posts/unit-integration-tests.html&text=Thoughts About Unit and Integration Tests&via=Pythux" title="Tweet" target="_blank" rel="noopener noreferrer"><img loading="lazy" alt="Tweet" src="/images/social_flat_rounded_rects_svg/Twitter.svg"><a></a></li><li><a href="https://getpocket.com/save?url=https://remusao.github.io//posts/unit-integration-tests.html&title=Thoughts About Unit and Integration Tests" title="Add to Pocket" target="_blank" rel="noopener noreferrer"><img loading="lazy" alt="Add to Pocket" src="/images/social_flat_rounded_rects_svg/Pocket.svg"><a></a></li><li><a href="https://news.ycombinator.com/submitlink?u=https://remusao.github.io//posts/unit-integration-tests.html&t=Thoughts About Unit and Integration Tests" title="Submit to Hacker News" target="_blank" rel="noopener noreferrer"><img loading="lazy" alt="Submit to Hacker News" src="/images/social_flat_rounded_rects_svg/HackerNews.svg"><a></a></li><li><a href="https://www.reddit.com/submit?url=https://remusao.github.io//posts/unit-integration-tests.html&title=Thoughts About Unit and Integration Tests" title="Submit to Reddit" target="_blank" rel="noopener noreferrer"><img loading="lazy" alt="Submit to Reddit" src="/images/social_flat_rounded_rects_svg/Reddit.svg"><a></a></li></ul></div></footer></main></body></html>