<!DOCTYPE html><html lang="fr" dir="ltr"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>C++, composition de fonctions</title><meta name="description" content="Simplex Sigillum Veri"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="canonical" href="https://remusao.github.io/posts/cpp-function-composition.html"><link rel="icon" type="image/x-icon" href="/images/favicon.ico"><style type="text/css">body{color:#2f2f2f;font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Oxygen-Sans,Ubuntu,Cantarell,'Helvetica Neue',sans-serif;line-height:1.6em;margin:20px auto;max-width:40rem;padding:0 1.5em;text-rendering:optimizeLegibility}h1,h2,h3{padding-top:.7em}h2{border-bottom:1px solid #eaecef;padding-bottom:.5em}.header,.main figcaption{color:#555;font-style:italic}.main a{color:#3465a4}.main a:visited{color:#75507b}.main figcaption{color:#696f72;line-height:2em;text-align:center}.main img{display:block;height:auto;margin:auto;padding-bottom:1em;padding-top:1em;width:90%}.main blockquote{border-left:thin solid #d3d7cf;color:#555;margin:10px;padding:0 0 0 1em}code{background-color:#f6f8fa;font-family:SFMono-Regular,Consolas,Liberation Mono,Menlo,monospace;font-size:14px;line-height:20px;padding:.2em .4em}pre code{display:block;overflow-x:auto}.leave-comment-btn,summary{font-size:16px;font-weight:600}.leave-comment-btn{background-color:#28a745;background-image:linear-gradient(-180deg,#34d058,#28a745 90%);border:1px solid rgba(27,31,35,.2);border-radius:.25em;color:#fff;display:inline-block;margin-top:1.5em;padding:3px 10px;text-decoration:none}.leave-comment-btn:hover{box-shadow:0 1px 3px rgba(0,0,0,.24)}summary{color:#516ae8;cursor:pointer;line-height:1.2rem;margin-top:2rem}.comments-list{list-style:none;padding:0}.comment{background-color:#fff;border:1px solid #d1d5da;border-radius:3px;color:#24292e;font-size:16px;margin:1em 0}.meta{background-color:#f6f8fa;border-bottom:1px solid #d1d5da;color:#586069}.author,.date{text-decoration:none}.author{color:#24292e!important;font-weight:700}.date{color:#586069}.date:hover{color:#0366d6}.content{padding-left:20px}.avatar,.emoji{vertical-align:middle}.avatar{display:inline-block;margin-right:5px}.emoji{height:1.1em;width:1.1em}table{border-collapse:collapse;margin:auto}td,th{border:1px solid #ddd;padding:10px}tr:hover{background-color:#f5f5f5}footer{border-top:thin solid #d3d7cf;margin:1.5em 0}.share ul{text-align:right}.share li{display:inline;padding:0 5px}.share img{width:2em}.main a,header a{text-decoration:none}.hljs{background:#f8f8f8;color:#333;display:block;overflow-x:auto;padding:.5em}.hljs-comment,.hljs-quote{color:#6a737d;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#d73a49}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:#005cc5}.hljs-doctag,.hljs-string{color:#032f62}.hljs-section,.hljs-selector-id,.hljs-title{color:#900}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#6f42c1}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style></head><body><main><header><h1><a href="../"><span>../</span></a></h1></header><h1>C++, composition de fonctions</h1><section class="header"><div>2013-05-30 | <em>Reading time: ~3 minutes</em></div></section><article><div class="main"><p>Lorsque l’on a gouté aux joies des langages fonctionnels, ou que l’on vient du monde des mathématiques, ou les deux, on est souvent habitué à “chainer” des appels de fonctions entre eux. Par exemple, si nous disposons de <code>n</code> fonctions de prototypes suivants :</p><pre><code class="language-haskell"><span class="hljs-title">f1</span> :: <span class="hljs-type">T1</span> -&gt; <span class="hljs-type">T2</span>
<span class="hljs-title">f2</span> :: <span class="hljs-type">T2</span> -&gt; <span class="hljs-type">T3</span>
...
<span class="hljs-title">fm</span> :: <span class="hljs-type">Tm</span> -&gt; <span class="hljs-type">Tn</span>
<span class="hljs-title">fn</span> :: <span class="hljs-type">Tn</span> -&gt; <span class="hljs-type">To</span></code></pre><p>Nous aimerions pouvoir les composer de la manière suivante :</p><pre><code class="language-haskell"><span class="hljs-title">fn</span> o fm o ... o f2 o f1</code></pre><p>Ce qui dans un langage comme C++ nous obligerait à faire :</p><pre><code class="language-c++"><span class="hljs-keyword">auto</span> res1 = f1(arg);
<span class="hljs-keyword">auto</span> res2 = f2(res1);
...
<span class="hljs-keyword">auto</span> resn = fn(resm);</code></pre><p>Ce qui est assez peu élégant. De plus, nous pourrions avoir envie qu’il n’y ait pas de copie dans les différents passages de paramètres (ce que nous pouvons faire en passant les arguments par référence, ou en utilisant un <em>move semantic</em>). Puisque nous ne faisons rien des résultats intermédiaires, nous aimerions disposer d’une fonction, qui prendrait les fonctions en arguments, ainsi que l’argument à donner à la première fonction, et s’occuperait de faire les appels successifs, tout en passant les arguments par move semantic ou référence. Une telle fonction peut-être créée en <code>c++11</code>, voici une solution possible.</p><p>L’idée est assez simple, nous utilisons un template récursif qui correspond a peu de choses près à la fonction suivante, le reste n’est que du surplut visant à propager les types et déterminer le type de retour des fonctions (avec <code>std::result_of</code>) :</p><pre><code class="language-c++">pipeline(arg, f1, f_suivantes) = pipeline(f1(arg), f_suivantes)</code></pre><p>Et enfin voici le code C++ correspondant :</p><pre><code class="language-c++">#ifndef PIPELINE_HH_
# define PIPELINE_HH_

namespace
{
    //
    // Extends the behavior of std::result_of for pipelines of function,
    // setting field type to the type returned by the last function of
    // the pipeline.
    //
    template &lt;typename In, typename F, typename ...Args&gt;
    struct result_of : public result_of&lt;typename std::result_of&lt;F(In)&gt;::type, Args...&gt; {};

    template &lt;typename In, typename F&gt;
    struct result_of&lt;In, F&gt;
    {
        typedef typename std::result_of&lt;F(In)&gt;::type type;
    };
}


//
// Pipeline of function
// usage : pipeline(T arg, f1, f2, ..., fn) with:
// f1: T -&gt; T1
// f2: T1 -&gt; T2
// ...
// fn: Tn -&gt; Tm
// returns the result of fn(...f2(f1(arg)))
//
template &lt;typename In&gt;
In pipeline(In&amp;&amp; a)
{
    return std::forward&lt;In&gt;(a);
}

template &lt;
    typename In,
    typename Function&gt;
auto pipeline(In&amp;&amp; a, Function f) -&gt; decltype (f(std::forward&lt;In&gt;(a)))
{
    return f(std::forward&lt;In&gt;(a));
}

template &lt;
    typename In,
    typename Function,
    typename ...Args&gt;
auto pipeline(In&amp;&amp; a, Function f, Args... args) -&gt; typename result_of&lt;In, Function, Args...&gt;::type
{
    return pipeline&lt;decltype (f(std::forward&lt;In&gt;(a)))&gt;(f(std::forward&lt;In&gt;(a)), args...);
}

#endif /* !PIPELINE_HH_ */</code></pre><p>N’hésitez pas à me faire part de vos remarques.</p></div><div class="comments"></div></article><footer><div class="share"><ul><li><a href="https://www.facebook.com/sharer/sharer.php?u=https://remusao.github.io//posts/cpp-function-composition.html&t=C++, composition de fonctions" title="Share on Facebook" target="_blank" rel="noopener noreferrer"><img loading="lazy" alt="Share on Facebook" src="/images/social_flat_rounded_rects_svg/Facebook.svg"><a></a></li><li><a href="https://twitter.com/share?url=https://remusao.github.io//posts/cpp-function-composition.html&text=C++, composition de fonctions&via=Pythux" title="Tweet" target="_blank" rel="noopener noreferrer"><img loading="lazy" alt="Tweet" src="/images/social_flat_rounded_rects_svg/Twitter.svg"><a></a></li><li><a href="https://getpocket.com/save?url=https://remusao.github.io//posts/cpp-function-composition.html&title=C++, composition de fonctions" title="Add to Pocket" target="_blank" rel="noopener noreferrer"><img loading="lazy" alt="Add to Pocket" src="/images/social_flat_rounded_rects_svg/Pocket.svg"><a></a></li><li><a href="https://news.ycombinator.com/submitlink?u=https://remusao.github.io//posts/cpp-function-composition.html&t=C++, composition de fonctions" title="Submit to Hacker News" target="_blank" rel="noopener noreferrer"><img loading="lazy" alt="Submit to Hacker News" src="/images/social_flat_rounded_rects_svg/HackerNews.svg"><a></a></li><li><a href="https://www.reddit.com/submit?url=https://remusao.github.io//posts/cpp-function-composition.html&title=C++, composition de fonctions" title="Submit to Reddit" target="_blank" rel="noopener noreferrer"><img loading="lazy" alt="Submit to Reddit" src="/images/social_flat_rounded_rects_svg/Reddit.svg"><a></a></li></ul></div></footer></main></body></html>