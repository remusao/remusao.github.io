<!DOCTYPE html><html lang="en" dir="ltr"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>The Sieve—Even faster!</title><meta name="description" content="Simplex Sigillum Veri"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="canonical" href="https://remusao.github.io/posts/sieve-even-faster.html"><link rel="icon" type="image/x-icon" href="/images/favicon.ico"><style type="text/css">body{color:#2f2f2f;font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Oxygen-Sans,Ubuntu,Cantarell,'Helvetica Neue',sans-serif;line-height:1.6em;margin:20px auto;max-width:40rem;padding:0 1.5em;text-rendering:optimizeLegibility}h1,h2,h3{padding-top:.7em}h2{border-bottom:1px solid #eaecef;padding-bottom:.5em}.header,.main figcaption{color:#555;font-style:italic}.main a{color:#3465a4}.main a:visited{color:#75507b}.main figcaption{color:#696f72;line-height:2em;text-align:center}.main img{display:block;height:auto;margin:auto;padding-bottom:1em;padding-top:1em;width:90%}.main blockquote{border-left:thin solid #d3d7cf;color:#555;margin:10px;padding:0 0 0 1em}code{background-color:#f6f8fa;font-family:SFMono-Regular,Consolas,Liberation Mono,Menlo,monospace;font-size:14px;line-height:20px;padding:.2em .4em}pre code{display:block;overflow-x:auto}.leave-comment-btn,summary{font-size:16px;font-weight:600}.leave-comment-btn{background-color:#28a745;background-image:linear-gradient(-180deg,#34d058,#28a745 90%);border:1px solid rgba(27,31,35,.2);border-radius:.25em;color:#fff;display:inline-block;margin-top:1.5em;padding:3px 10px;text-decoration:none}.leave-comment-btn:hover{box-shadow:0 1px 3px rgba(0,0,0,.24)}summary{color:#516ae8;cursor:pointer;line-height:1.2rem;margin-top:2rem}.comments-list{list-style:none;padding:0}.comment{background-color:#fff;border:1px solid #d1d5da;border-radius:3px;color:#24292e;font-size:16px;margin:1em 0}.meta{background-color:#f6f8fa;border-bottom:1px solid #d1d5da;color:#586069}.author,.date{text-decoration:none}.author{color:#24292e!important;font-weight:700}.date{color:#586069}.date:hover{color:#0366d6}.content{padding-left:20px}.avatar,.emoji{vertical-align:middle}.avatar{display:inline-block;margin-right:5px}.emoji{height:1.1em;width:1.1em}table{border-collapse:collapse;margin:auto}td,th{border:1px solid #ddd;padding:10px}tr:hover{background-color:#f5f5f5}footer{border-top:thin solid #d3d7cf;margin:1.5em 0}.share ul{text-align:right}.share li{display:inline;padding:0 5px}.share img{width:2em}.main a,header a{text-decoration:none}.hljs{background:#f8f8f8;color:#333;display:block;overflow-x:auto;padding:.5em}.hljs-comment,.hljs-quote{color:#6a737d;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#d73a49}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:#005cc5}.hljs-doctag,.hljs-string{color:#032f62}.hljs-section,.hljs-selector-id,.hljs-title{color:#900}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#6f42c1}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style></head><body><main><header><h1><a href="../"><span>../</span></a></h1></header><h1>The Sieve—Even faster!</h1><section class="header"><div>2011-12-27 | <em>Reading time: ~5 minutes</em></div></section><article><div class="main"><p><strong>Disclaimer</strong>: This is an old article and information may be out-dated. You can find one of the (if not <em>the</em>) fastest implementation there: <a href="http://primesieve.org/">http://primesieve.org/</a></p><p>It has been a while since I posted my last article on the blog, my studies didn’t leave me enough time for writing. But during Christmas holidays I found some time to share with you some discoveries and developments that I made recently on the Sieve of Eratosthenes. This article follows the previous article on the Sieve and aim to present some optimizations and an attempt to determine the complexity of the algorithm.</p><h2 id="last-optimizations">Last optimizations</h2><p>Optimizations that follow are the result of several comments on the above implementations:</p><ul><li>Could we not reduce the memory footprint of the program by working only on arrays of bits instead of chars ? (We could divide the memory used by 8).</li><li>In the main loop, our variable i ranges from 1 in 1, and values are not always prime numbers, so there is no need to eliminate their multiples.</li></ul><p>For the second optimization, we just have to get the next number that has not yet been eliminated. With a simple loop. We then gain precious seconds at runtime.</p><p>Regarding the first optimization, it turns out that it’s not easy to work directly on the bits in C, except with bit fields, but this is complicated in the case of the Sieve of Eratosthenes. So I decided to implement the algorithm in C++, which offers the type bool, which takes only one bit in memory as well as Bitset, which are nothing more than arrays of bits, provided with various operations. Thanks to a std::vector (or a simple array) of bool the memory usage of the program is reduced by 8, which is pretty good. But it’s possible to use a data structure more efficient. You certainly heard about Boost, a library which provide many very powerful tools for C++, and among this tools is the Bitset (it also exists in STD, but it is less efficient). Using Bitset, we gain a little in runtime.</p><p>Note that Boost Bitset are initialized to 0 by default, so we must consider that a number is prime if the value associated in the array is 0 (and not 1 as in a previous implementations).</p><pre><code class="language-c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;boost/dynamic_bitset.hpp&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">print_tab</span> <span class="hljs-params">(boost::dynamic_bitset&lt;&gt;&amp; tab)</span>
</span>{
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-number">2</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> i = <span class="hljs-number">1</span>; i &lt; tab.<span class="hljs-built_in">size</span> (); i++)
    <span class="hljs-keyword">if</span> (!tab[i])
      <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
}

<span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">erato</span> <span class="hljs-params">(boost::dynamic_bitset&lt;&gt;&amp; tab)</span>
</span>{
  <span class="hljs-keyword">unsigned</span> i = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">unsigned</span> j, <span class="hljs-built_in">step</span>, borne = <span class="hljs-built_in">sqrt</span> (tab.<span class="hljs-built_in">size</span> ());

  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; borne; i++)
  {
    <span class="hljs-built_in">step</span> = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>;
    <span class="hljs-keyword">for</span> (j = i + <span class="hljs-built_in">step</span>; j &lt; tab.<span class="hljs-built_in">size</span> (); j += <span class="hljs-built_in">step</span>)
      tab[j] = <span class="hljs-number">1</span>;

    <span class="hljs-keyword">while</span> (tab[i])
      i++;
  }
}

<span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span>
</span>{
  <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">2</span>)
  {
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Please, you must give a number as argument."</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
  }

  <span class="hljs-keyword">unsigned</span> <span class="hljs-built_in">size</span> = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> i = <span class="hljs-number">0</span>; argv[<span class="hljs-number">1</span>][i]; i++)
    <span class="hljs-built_in">size</span> = <span class="hljs-built_in">size</span> * <span class="hljs-number">10</span> + (argv[<span class="hljs-number">1</span>][i] - <span class="hljs-string">'0'</span>);

  boost::dynamic_bitset&lt;&gt;* tab = <span class="hljs-keyword">new</span> boost::dynamic_bitset&lt;&gt; (<span class="hljs-built_in">size</span> / <span class="hljs-number">2</span>);

  erato (*tab);
  <span class="hljs-comment">//print_tab (*tab);</span>
}</code></pre><p>With this algorithm we get much better performance than with the previous implementation.</p><h2 id="complexity-approximation">Complexity approximation</h2><p>The complexity of an algorithm is used to express the number of operations needed to execution depending on the size of the input (in our case it will be the limit up to which we want to calculate the prime numbers).</p><p>Soon I will post a more accurate approximation of the complexity of this algorithm, but my initial investigations suggest that the complexity is linear (3xN?).</p><h2 id="the-last-words">The last words</h2><p>After presenting a number of optimizations to the algorithm of the Sieve of Eratosthenes, we saw that it is always possible to improve a program, and this, in two lines of research. First, one can often optimize the algorithm itself, by choosing appropriate data structures, trying to reduce the memory footprint or by reducing the number of calculations needed to compute the result, etc. .. One can also optimize the implementation of the algorithm, it’s often the last step, during which we will try to find tips, related to language itself, that allow us to make our program faster by changing the compiler flags (-O, -march, etc. ..), etc. ..</p><p>The last implementation presented in this article is far from being the most optimized, we could still find ways to improve performances, for exemple by eliminating multiples of 3, 5 and 7 at the initialization of the array or by using bit masks to eliminate several multiples at a time. However, keep in mind that it is difficult to keep the compactness and readability of our algorithm with such optimizations.</p><p>If you know other optimizations, or have any comments on this article, feel free to contact me or leave a comment below.</p></div><div class="comments"></div></article><footer><div class="share"><ul><li><a href="https://www.facebook.com/sharer/sharer.php?u=https://remusao.github.io//posts/sieve-even-faster.html&t=The Sieve—Even faster!" title="Share on Facebook" target="_blank" rel="noopener noreferrer"><img loading="lazy" alt="Share on Facebook" src="/images/social_flat_rounded_rects_svg/Facebook.svg"><a></a></li><li><a href="https://twitter.com/share?url=https://remusao.github.io//posts/sieve-even-faster.html&text=The Sieve—Even faster!&via=Pythux" title="Tweet" target="_blank" rel="noopener noreferrer"><img loading="lazy" alt="Tweet" src="/images/social_flat_rounded_rects_svg/Twitter.svg"><a></a></li><li><a href="https://getpocket.com/save?url=https://remusao.github.io//posts/sieve-even-faster.html&title=The Sieve—Even faster!" title="Add to Pocket" target="_blank" rel="noopener noreferrer"><img loading="lazy" alt="Add to Pocket" src="/images/social_flat_rounded_rects_svg/Pocket.svg"><a></a></li><li><a href="https://news.ycombinator.com/submitlink?u=https://remusao.github.io//posts/sieve-even-faster.html&t=The Sieve—Even faster!" title="Submit to Hacker News" target="_blank" rel="noopener noreferrer"><img loading="lazy" alt="Submit to Hacker News" src="/images/social_flat_rounded_rects_svg/HackerNews.svg"><a></a></li><li><a href="https://www.reddit.com/submit?url=https://remusao.github.io//posts/sieve-even-faster.html&title=The Sieve—Even faster!" title="Submit to Reddit" target="_blank" rel="noopener noreferrer"><img loading="lazy" alt="Submit to Reddit" src="/images/social_flat_rounded_rects_svg/Reddit.svg"><a></a></li></ul></div></footer></main></body></html>